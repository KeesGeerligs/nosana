import { LlmSchemaSeparator } from "../utils/LlmSchemaSeparator.mjs";

import { LlmTypeChecker } from "../utils/LlmTypeChecker.mjs";

import { OpenApiTypeChecker } from "../utils/OpenApiTypeChecker.mjs";

import { OpenApiV3Downgrader } from "./OpenApiV3Downgrader.mjs";

var HttpLlmConverter;

(function(HttpLlmConverter) {
    HttpLlmConverter.compose = (migrate, options) => {
        const errors = migrate.errors.map((e => ({
            method: e.method,
            path: e.path,
            messages: e.messages,
            operation: () => e.operation(),
            route: () => undefined
        })));
        const functions = migrate.routes.map((route => {
            if (route.method === "head") return null;
            const func = composeFunction(options)(migrate.document().components)(route);
            if (func === null) errors.push({
                method: route.method,
                path: route.path,
                messages: [ "Failed to escape $ref" ],
                operation: () => route.operation(),
                route: () => route
            });
            return func;
        })).filter((v => v !== null));
        return {
            openapi: "3.0.3",
            functions,
            errors,
            options
        };
    };
    HttpLlmConverter.schema = props => {
        const resolved = escape({
            components: props.components,
            visited: new Set,
            input: props.schema
        });
        if (resolved === null) return null;
        const downgraded = OpenApiV3Downgrader.downgradeSchema({
            original: {},
            downgraded: {}
        })(resolved);
        LlmTypeChecker.visit(downgraded, (schema => {
            if (LlmTypeChecker.isOneOf(schema) && schema.discriminator !== undefined) delete schema.discriminator;
        }));
        return downgraded;
    };
})(HttpLlmConverter || (HttpLlmConverter = {}));

const composeFunction = options => components => route => {
    const cast = s => HttpLlmConverter.schema({
        components,
        schema: s
    });
    const output = route.success && route.success ? cast(route.success.schema) : undefined;
    if (output === null) return null;
    const properties = [ ...route.parameters.map((p => ({
        key: p.key,
        schema: {
            ...p.schema,
            title: p.parameter().title ?? p.schema.title,
            description: p.parameter().description ?? p.schema.description
        }
    }))), ...route.query ? [ {
        key: route.query.key,
        schema: {
            ...route.query.schema,
            title: route.query.title() ?? route.query.schema.title,
            description: route.query.description() ?? route.query.schema.description
        }
    } ] : [], ...route.body ? [ {
        key: route.body.key,
        schema: {
            ...route.body.schema,
            description: route.body.description() ?? route.body.schema.description
        }
    } ] : [] ].map((o => [ o.key, cast(o.schema) ]));
    if (properties.some((([_k, v]) => v === null))) return null;
    const parameters = options.keyword ? [ {
        type: "object",
        properties: Object.fromEntries(properties)
    } ] : properties.map((([_k, v]) => v));
    const operation = route.operation();
    return {
        method: route.method,
        path: route.path,
        name: route.accessor.join("_"),
        strict: true,
        parameters,
        separated: options.separate ? LlmSchemaSeparator.parameters({
            parameters,
            predicator: options.separate
        }) : undefined,
        output: output ? OpenApiV3Downgrader.downgradeSchema({
            original: {},
            downgraded: {}
        })(output) : undefined,
        description: (() => {
            if (operation.summary && operation.description) {
                return operation.description.startsWith(operation.summary) ? operation.description : [ operation.summary, operation.summary.endsWith(".") ? "" : ".", "\n\n", operation.description ].join("");
            }
            return operation.description ?? operation.summary;
        })(),
        deprecated: operation.deprecated,
        tags: operation.tags,
        route: () => route,
        operation: () => operation
    };
};

const escape = props => {
    if (OpenApiTypeChecker.isReference(props.input)) {
        const name = props.input.$ref.split("#/components/schemas/")[1];
        const target = props.components.schemas?.[name];
        if (!target) return null; else if (props.visited.has(name)) return null;
        return escape({
            components: props.components,
            visited: new Set([ ...props.visited, name ]),
            input: target
        });
    } else if (OpenApiTypeChecker.isOneOf(props.input)) {
        const oneOf = props.input.oneOf.map((schema => escape({
            ...props,
            input: schema
        })));
        if (oneOf.some((v => v === null))) return null;
        return {
            ...props.input,
            oneOf: flat(oneOf)
        };
    } else if (OpenApiTypeChecker.isObject(props.input)) {
        const properties = props.input.properties ? Object.entries(props.input.properties).map((([key, value]) => [ key, escape({
            ...props,
            input: value
        }) ])) : undefined;
        const additionalProperties = props.input.additionalProperties ? typeof props.input.additionalProperties === "object" && props.input.additionalProperties !== null ? escape({
            ...props,
            input: props.input.additionalProperties
        }) : props.input.additionalProperties : undefined;
        if (properties && properties.some((([_k, v]) => v === null))) return null; else if (additionalProperties === null) return null;
        return {
            ...props.input,
            properties: properties ? Object.fromEntries(properties.filter((([_k, v]) => !!v))) : undefined,
            additionalProperties
        };
    } else if (OpenApiTypeChecker.isTuple(props.input)) {
        const prefixItems = props.input.prefixItems.map((schema => escape({
            ...props,
            input: schema
        })));
        const additionalItems = typeof props.input.additionalItems === "object" && props.input.additionalItems !== null ? escape({
            ...props,
            input: props.input.additionalItems
        }) : props.input.additionalItems;
        if (prefixItems.some((v => v === null))) return null; else if (additionalItems === null) return null;
        return {
            ...props.input,
            prefixItems,
            additionalItems
        };
    } else if (OpenApiTypeChecker.isArray(props.input)) {
        const items = escape({
            ...props,
            input: props.input.items
        });
        if (items === null) return null;
        return {
            ...props.input,
            items
        };
    }
    return props.input;
};

const flat = elements => elements.map((elem => OpenApiTypeChecker.isOneOf(elem) ? flat(elem.oneOf) : elem)).flat();

export { HttpLlmConverter };
//# sourceMappingURL=HttpLlmConverter.mjs.map
