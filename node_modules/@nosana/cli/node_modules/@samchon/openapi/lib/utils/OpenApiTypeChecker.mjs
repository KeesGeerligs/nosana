import { MapUtil } from "./MapUtil.mjs";

var OpenApiTypeChecker;

(function(OpenApiTypeChecker) {
    OpenApiTypeChecker.visit = closure => components => {
        const already = new Set;
        const next = schema => {
            closure(schema);
            if (OpenApiTypeChecker.isReference(schema)) {
                const key = schema.$ref.split("#/components/schemas/").pop();
                if (already.has(key) === true) return;
                already.add(key);
                const found = components.schemas?.[key];
                if (found !== undefined) next(found);
            } else if (OpenApiTypeChecker.isOneOf(schema)) schema.oneOf.forEach(next); else if (OpenApiTypeChecker.isObject(schema)) {
                for (const value of Object.values(schema.properties ?? {})) next(value);
                if (typeof schema.additionalProperties === "object" && schema.additionalProperties !== null) next(schema.additionalProperties);
            } else if (OpenApiTypeChecker.isArray(schema)) next(schema.items); else if (OpenApiTypeChecker.isTuple(schema)) {
                (schema.prefixItems ?? []).forEach(next);
                if (typeof schema.additionalItems === "object" && schema.additionalItems !== null) next(schema.additionalItems);
            }
        };
        return next;
    };
    OpenApiTypeChecker.isNull = schema => schema.type === "null";
    OpenApiTypeChecker.isUnknown = schema => schema.type === undefined && !OpenApiTypeChecker.isConstant(schema) && !OpenApiTypeChecker.isOneOf(schema) && !OpenApiTypeChecker.isReference(schema);
    OpenApiTypeChecker.isConstant = schema => schema.const !== undefined;
    OpenApiTypeChecker.isBoolean = schema => schema.type === "boolean";
    OpenApiTypeChecker.isInteger = schema => schema.type === "integer";
    OpenApiTypeChecker.isNumber = schema => schema.type === "number";
    OpenApiTypeChecker.isString = schema => schema.type === "string";
    OpenApiTypeChecker.isArray = schema => schema.type === "array" && schema.items !== undefined;
    OpenApiTypeChecker.isTuple = schema => schema.type === "array" && schema.prefixItems !== undefined;
    OpenApiTypeChecker.isObject = schema => schema.type === "object";
    OpenApiTypeChecker.isReference = schema => schema.$ref !== undefined;
    OpenApiTypeChecker.isOneOf = schema => schema.oneOf !== undefined;
    OpenApiTypeChecker.covers = components => coverStation(components)(new Map);
    const coverStation = components => visited => (x, y) => {
        const cache = visited.get(x)?.get(y);
        if (cache !== undefined) return cache;
        const nested = MapUtil.take(visited)(x)((() => new Map));
        nested.set(y, true);
        const result = coverSchema(components)(visited)(x, y);
        nested.set(y, result);
        return result;
    };
    const coverSchema = components => visited => (x, y) => {
        if (x === y) return true; else if (OpenApiTypeChecker.isReference(x) && OpenApiTypeChecker.isReference(y) && x.$ref === y.$ref) return true;
        const alpha = flatSchema(components)(x);
        const beta = flatSchema(components)(y);
        if (alpha.some((x => OpenApiTypeChecker.isUnknown(x)))) return true; else if (beta.some((x => OpenApiTypeChecker.isUnknown(x)))) return false;
        return beta.every((b => alpha.some((a => coverEscapedSchema(components)(visited)(a, b)))));
    };
    const coverEscapedSchema = components => visited => (x, y) => {
        if (x === y) return true; else if (OpenApiTypeChecker.isUnknown(x)) return true; else if (OpenApiTypeChecker.isUnknown(y)) return false; else if (OpenApiTypeChecker.isNull(x)) return OpenApiTypeChecker.isNull(y); else if (OpenApiTypeChecker.isConstant(x)) return OpenApiTypeChecker.isConstant(y) && x.const === y.const; else if (OpenApiTypeChecker.isBoolean(x)) return OpenApiTypeChecker.isBoolean(y) || OpenApiTypeChecker.isConstant(y) && typeof y.const === "boolean"; else if (OpenApiTypeChecker.isInteger(x)) return (OpenApiTypeChecker.isInteger(y) || OpenApiTypeChecker.isConstant(y)) && coverInteger(x, y); else if (OpenApiTypeChecker.isNumber(x)) return (OpenApiTypeChecker.isConstant(y) || OpenApiTypeChecker.isInteger(y) || OpenApiTypeChecker.isNumber(y)) && coverNumber(x, y); else if (OpenApiTypeChecker.isString(x)) return (OpenApiTypeChecker.isConstant(y) || OpenApiTypeChecker.isString(y)) && coverString(x, y); else if (OpenApiTypeChecker.isArray(x)) return (OpenApiTypeChecker.isArray(y) || OpenApiTypeChecker.isTuple(y)) && coverArray(components)(visited)(x, y); else if (OpenApiTypeChecker.isObject(x)) return OpenApiTypeChecker.isObject(y) && coverObject(components)(visited)(x, y); else if (OpenApiTypeChecker.isReference(x)) return OpenApiTypeChecker.isReference(y) && x.$ref === y.$ref;
        return false;
    };
    const coverArray = components => visited => (x, y) => {
        if (OpenApiTypeChecker.isTuple(y)) return y.prefixItems.every((v => coverStation(components)(visited)(x.items, v))) && (y.additionalItems === undefined || typeof y.additionalItems === "object" && coverStation(components)(visited)(x.items, y.additionalItems)); else if (!(x.minItems === undefined || y.minItems !== undefined && x.minItems <= y.minItems)) return false; else if (!(x.maxItems === undefined || y.maxItems !== undefined && x.maxItems >= y.maxItems)) return false;
        return coverStation(components)(visited)(x.items, y.items);
    };
    const coverObject = components => visited => (x, y) => {
        if (!x.additionalProperties && !!y.additionalProperties) return false; else if (!!x.additionalProperties && !!y.additionalProperties && (typeof x.additionalProperties === "object" && y.additionalProperties === true || typeof x.additionalProperties === "object" && typeof y.additionalProperties === "object" && !coverStation(components)(visited)(x.additionalProperties, y.additionalProperties))) return false;
        return Object.entries(y.properties ?? {}).every((([key, b]) => {
            const a = x.properties?.[key];
            if (a === undefined) return false; else if ((x.required?.includes(key) ?? false) === true && (y.required?.includes(key) ?? false) === false) return false;
            return coverStation(components)(visited)(a, b);
        }));
    };
    const coverInteger = (x, y) => {
        if (OpenApiTypeChecker.isConstant(y)) return typeof y.const === "number" && Number.isInteger(y.const);
        return [ x.type === y.type, x.minimum === undefined || y.minimum !== undefined && x.minimum <= y.minimum, x.maximum === undefined || y.maximum !== undefined && x.maximum >= y.maximum, x.exclusiveMinimum !== true || x.minimum === undefined || y.minimum !== undefined && (y.exclusiveMinimum === true || x.minimum < y.minimum), x.exclusiveMaximum !== true || x.maximum === undefined || y.maximum !== undefined && (y.exclusiveMaximum === true || x.maximum > y.maximum), x.multipleOf === undefined || y.multipleOf !== undefined && y.multipleOf / x.multipleOf === Math.floor(y.multipleOf / x.multipleOf) ].every((v => v));
    };
    const coverNumber = (x, y) => {
        if (OpenApiTypeChecker.isConstant(y)) return typeof y.const === "number";
        return [ x.type === y.type || x.type === "number" && y.type === "integer", x.minimum === undefined || y.minimum !== undefined && x.minimum <= y.minimum, x.maximum === undefined || y.maximum !== undefined && x.maximum >= y.maximum, x.exclusiveMinimum !== true || x.minimum === undefined || y.minimum !== undefined && (y.exclusiveMinimum === true || x.minimum < y.minimum), x.exclusiveMaximum !== true || x.maximum === undefined || y.maximum !== undefined && (y.exclusiveMaximum === true || x.maximum > y.maximum), x.multipleOf === undefined || y.multipleOf !== undefined && y.multipleOf / x.multipleOf === Math.floor(y.multipleOf / x.multipleOf) ].every((v => v));
    };
    const coverString = (x, y) => {
        if (OpenApiTypeChecker.isConstant(y)) return typeof y.const === "string";
        return [ x.format === undefined || y.format !== undefined && coverFormat(x.format, y.format), x.pattern === undefined || x.pattern === y.pattern, x.minLength === undefined || y.minLength !== undefined && x.minLength <= y.minLength, x.maxLength === undefined || y.maxLength !== undefined && x.maxLength >= y.maxLength ].every((v => v));
    };
    const coverFormat = (x, y) => x === y || x === "idn-email" && y === "email" || x === "idn-hostname" && y === "hostname" || [ "uri", "iri" ].includes(x) && y === "url" || x === "iri" && y === "uri" || x === "iri-reference" && y === "uri-reference";
    const flatSchema = components => schema => {
        schema = escapeReference(components)(schema);
        if (OpenApiTypeChecker.isOneOf(schema)) return schema.oneOf.map(flatSchema(components)).flat();
        return [ schema ];
    };
    const escapeReference = components => schema => OpenApiTypeChecker.isReference(schema) ? escapeReference(components)(components.schemas[schema.$ref.replace("#/components/schemas/", "")]) : schema;
})(OpenApiTypeChecker || (OpenApiTypeChecker = {}));

export { OpenApiTypeChecker };
//# sourceMappingURL=OpenApiTypeChecker.mjs.map
