"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LlmTypeChecker = void 0;
/**
 * Type checker for LLM type schema.
 *
 * `LlmSchemaTypeChecker` is a type checker of {@link ILlmSchema}.
 *
 * @author Samchon
 */
var LlmTypeChecker;
(function (LlmTypeChecker) {
    /**
     * Visit every nested schemas.
     *
     * Visit every nested schemas of the target, and apply the callback function
     * to them.
     *
     * If the visitor meets an union type, it will visit every individual schemas
     * in the union type. Otherwise meets an object type, it will visit every
     * properties and additional properties. If the visitor meets an array type,
     * it will visit the item type.
     *
     * @param schema Target schema to visit
     * @param callback Callback function to apply
     */
    LlmTypeChecker.visit = function (schema, callback) {
        var e_1, _a;
        var _b;
        callback(schema);
        if (LlmTypeChecker.isOneOf(schema))
            schema.oneOf.forEach(function (s) { return LlmTypeChecker.visit(s, callback); });
        else if (LlmTypeChecker.isObject(schema)) {
            try {
                for (var _c = __values(Object.entries((_b = schema.properties) !== null && _b !== void 0 ? _b : {})), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), _ = _e[0], s = _e[1];
                    LlmTypeChecker.visit(s, callback);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (typeof schema.additionalProperties === "object" &&
                schema.additionalProperties !== null)
                LlmTypeChecker.visit(schema.additionalProperties, callback);
        }
        else if (LlmTypeChecker.isArray(schema))
            LlmTypeChecker.visit(schema.items, callback);
    };
    /**
     * Test whether the schema is an union type.
     *
     * @param schema Target schema
     * @returns Whether union type or not
     */
    LlmTypeChecker.isOneOf = function (schema) {
        return schema.oneOf !== undefined;
    };
    /**
     * Test whether the schema is an object type.
     *
     * @param schema Target schema
     * @returns Whether object type or not
     */
    LlmTypeChecker.isObject = function (schema) {
        return schema.type === "object";
    };
    /**
     * Test whether the schema is an array type.
     *
     * @param schema Target schema
     * @returns Whether array type or not
     */
    LlmTypeChecker.isArray = function (schema) {
        return schema.type === "array";
    };
    /**
     * Test whether the schema is a boolean type.
     *
     * @param schema Target schema
     * @returns Whether boolean type or not
     */
    LlmTypeChecker.isBoolean = function (schema) {
        return schema.type === "boolean";
    };
    /**
     * Test whether the schema is an integer type.
     *
     * @param schema Target schema
     * @returns Whether integer type or not
     */
    LlmTypeChecker.isInteger = function (schema) {
        return schema.type === "integer";
    };
    /**
     * Test whether the schema is a number type.
     *
     * @param schema Target schema
     * @returns Whether number type or not
     */
    LlmTypeChecker.isNumber = function (schema) {
        return schema.type === "number";
    };
    /**
     * Test whether the schema is a string type.
     *
     * @param schema Target schema
     * @returns Whether string type or not
     */
    LlmTypeChecker.isString = function (schema) {
        return schema.type === "string";
    };
    /**
     * Test whether the schema is a null type.
     *
     * @param schema Target schema
     * @returns Whether null type or not
     */
    LlmTypeChecker.isNullOnly = function (schema) {
        return schema.type === "null";
    };
    /**
     * Test whether the schema is a nullable type.
     *
     * @param schema Target schema
     * @returns Whether nullable type or not
     */
    LlmTypeChecker.isNullable = function (schema) {
        return !LlmTypeChecker.isUnknown(schema) &&
            (LlmTypeChecker.isNullOnly(schema) ||
                (LlmTypeChecker.isOneOf(schema)
                    ? schema.oneOf.some(LlmTypeChecker.isNullable)
                    : schema.nullable === true));
    };
    /**
     * Test whether the schema is an unknown type.
     *
     * @param schema Target schema
     * @returns Whether unknown type or not
     */
    LlmTypeChecker.isUnknown = function (schema) {
        return !LlmTypeChecker.isOneOf(schema) && schema.type === undefined;
    };
})(LlmTypeChecker || (exports.LlmTypeChecker = LlmTypeChecker = {}));
