"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenApiTypeChecker = void 0;
var MapUtil_1 = require("./MapUtil");
var OpenApiTypeChecker;
(function (OpenApiTypeChecker) {
    OpenApiTypeChecker.visit = function (closure) {
        return function (components) {
            var already = new Set();
            var next = function (schema) {
                var e_1, _a;
                var _b, _c, _d;
                closure(schema);
                if (OpenApiTypeChecker.isReference(schema)) {
                    var key = schema.$ref.split("#/components/schemas/").pop();
                    if (already.has(key) === true)
                        return;
                    already.add(key);
                    var found = (_b = components.schemas) === null || _b === void 0 ? void 0 : _b[key];
                    if (found !== undefined)
                        next(found);
                }
                else if (OpenApiTypeChecker.isOneOf(schema))
                    schema.oneOf.forEach(next);
                else if (OpenApiTypeChecker.isObject(schema)) {
                    try {
                        for (var _e = __values(Object.values((_c = schema.properties) !== null && _c !== void 0 ? _c : {})), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var value = _f.value;
                            next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    if (typeof schema.additionalProperties === "object" &&
                        schema.additionalProperties !== null)
                        next(schema.additionalProperties);
                }
                else if (OpenApiTypeChecker.isArray(schema))
                    next(schema.items);
                else if (OpenApiTypeChecker.isTuple(schema)) {
                    ((_d = schema.prefixItems) !== null && _d !== void 0 ? _d : []).forEach(next);
                    if (typeof schema.additionalItems === "object" &&
                        schema.additionalItems !== null)
                        next(schema.additionalItems);
                }
            };
            return next;
        };
    };
    /* -----------------------------------------------------------
      TYPE CHECKERS
    ----------------------------------------------------------- */
    OpenApiTypeChecker.isNull = function (schema) {
        return schema.type === "null";
    };
    OpenApiTypeChecker.isUnknown = function (schema) {
        return schema.type === undefined &&
            !OpenApiTypeChecker.isConstant(schema) &&
            !OpenApiTypeChecker.isOneOf(schema) &&
            !OpenApiTypeChecker.isReference(schema);
    };
    OpenApiTypeChecker.isConstant = function (schema) {
        return schema.const !== undefined;
    };
    OpenApiTypeChecker.isBoolean = function (schema) {
        return schema.type === "boolean";
    };
    OpenApiTypeChecker.isInteger = function (schema) {
        return schema.type === "integer";
    };
    OpenApiTypeChecker.isNumber = function (schema) {
        return schema.type === "number";
    };
    OpenApiTypeChecker.isString = function (schema) {
        return schema.type === "string";
    };
    OpenApiTypeChecker.isArray = function (schema) {
        return schema.type === "array" &&
            schema.items !== undefined;
    };
    OpenApiTypeChecker.isTuple = function (schema) {
        return schema.type === "array" &&
            schema.prefixItems !== undefined;
    };
    OpenApiTypeChecker.isObject = function (schema) {
        return schema.type === "object";
    };
    OpenApiTypeChecker.isReference = function (schema) {
        return schema.$ref !== undefined;
    };
    OpenApiTypeChecker.isOneOf = function (schema) {
        return schema.oneOf !== undefined;
    };
    /* -----------------------------------------------------------
      OPERATORS
    ----------------------------------------------------------- */
    OpenApiTypeChecker.covers = function (components) {
        return coverStation(components)(new Map());
    };
    var coverStation = function (components) {
        return function (visited) {
            return function (x, y) {
                var _a;
                var cache = (_a = visited.get(x)) === null || _a === void 0 ? void 0 : _a.get(y);
                if (cache !== undefined)
                    return cache;
                // FOR RECURSIVE CASE
                var nested = MapUtil_1.MapUtil.take(visited)(x)(function () { return new Map(); });
                nested.set(y, true);
                // COMPUTE IT
                var result = coverSchema(components)(visited)(x, y);
                nested.set(y, result);
                return result;
            };
        };
    };
    var coverSchema = function (components) {
        return function (visited) {
            return function (x, y) {
                // CHECK EQUALITY
                if (x === y)
                    return true;
                else if (OpenApiTypeChecker.isReference(x) && OpenApiTypeChecker.isReference(y) && x.$ref === y.$ref)
                    return true;
                // COMPARE WITH FLATTENING
                var alpha = flatSchema(components)(x);
                var beta = flatSchema(components)(y);
                if (alpha.some(function (x) { return OpenApiTypeChecker.isUnknown(x); }))
                    return true;
                else if (beta.some(function (x) { return OpenApiTypeChecker.isUnknown(x); }))
                    return false;
                return beta.every(function (b) {
                    return alpha.some(function (a) { return coverEscapedSchema(components)(visited)(a, b); });
                });
            };
        };
    };
    var coverEscapedSchema = function (components) {
        return function (visited) {
            return function (x, y) {
                // CHECK EQUALITY
                if (x === y)
                    return true;
                else if (OpenApiTypeChecker.isUnknown(x))
                    return true;
                else if (OpenApiTypeChecker.isUnknown(y))
                    return false;
                else if (OpenApiTypeChecker.isNull(x))
                    return OpenApiTypeChecker.isNull(y);
                // ATOMIC CASE
                else if (OpenApiTypeChecker.isConstant(x))
                    return OpenApiTypeChecker.isConstant(y) && x.const === y.const;
                else if (OpenApiTypeChecker.isBoolean(x))
                    return OpenApiTypeChecker.isBoolean(y) || (OpenApiTypeChecker.isConstant(y) && typeof y.const === "boolean");
                else if (OpenApiTypeChecker.isInteger(x))
                    return (OpenApiTypeChecker.isInteger(y) || OpenApiTypeChecker.isConstant(y)) && coverInteger(x, y);
                else if (OpenApiTypeChecker.isNumber(x))
                    return ((OpenApiTypeChecker.isConstant(y) || OpenApiTypeChecker.isInteger(y) || OpenApiTypeChecker.isNumber(y)) && coverNumber(x, y));
                else if (OpenApiTypeChecker.isString(x))
                    return (OpenApiTypeChecker.isConstant(y) || OpenApiTypeChecker.isString(y)) && coverString(x, y);
                // INSTANCE CASE
                else if (OpenApiTypeChecker.isArray(x))
                    return ((OpenApiTypeChecker.isArray(y) || OpenApiTypeChecker.isTuple(y)) && coverArray(components)(visited)(x, y));
                else if (OpenApiTypeChecker.isObject(x))
                    return OpenApiTypeChecker.isObject(y) && coverObject(components)(visited)(x, y);
                else if (OpenApiTypeChecker.isReference(x))
                    return OpenApiTypeChecker.isReference(y) && x.$ref === y.$ref;
                return false;
            };
        };
    };
    var coverArray = function (components) {
        return function (visited) {
            return function (x, y) {
                if (OpenApiTypeChecker.isTuple(y))
                    return (y.prefixItems.every(function (v) {
                        return coverStation(components)(visited)(x.items, v);
                    }) &&
                        (y.additionalItems === undefined ||
                            (typeof y.additionalItems === "object" &&
                                coverStation(components)(visited)(x.items, y.additionalItems))));
                else if (!(x.minItems === undefined ||
                    (y.minItems !== undefined && x.minItems <= y.minItems)))
                    return false;
                else if (!(x.maxItems === undefined ||
                    (y.maxItems !== undefined && x.maxItems >= y.maxItems)))
                    return false;
                return coverStation(components)(visited)(x.items, y.items);
            };
        };
    };
    var coverObject = function (components) {
        return function (visited) {
            return function (x, y) {
                var _a;
                if (!x.additionalProperties && !!y.additionalProperties)
                    return false;
                else if (!!x.additionalProperties &&
                    !!y.additionalProperties &&
                    ((typeof x.additionalProperties === "object" &&
                        y.additionalProperties === true) ||
                        (typeof x.additionalProperties === "object" &&
                            typeof y.additionalProperties === "object" &&
                            !coverStation(components)(visited)(x.additionalProperties, y.additionalProperties))))
                    return false;
                return Object.entries((_a = y.properties) !== null && _a !== void 0 ? _a : {}).every(function (_a) {
                    var _b, _c, _d, _e, _f;
                    var _g = __read(_a, 2), key = _g[0], b = _g[1];
                    var a = (_b = x.properties) === null || _b === void 0 ? void 0 : _b[key];
                    if (a === undefined)
                        return false;
                    else if (((_d = (_c = x.required) === null || _c === void 0 ? void 0 : _c.includes(key)) !== null && _d !== void 0 ? _d : false) === true &&
                        ((_f = (_e = y.required) === null || _e === void 0 ? void 0 : _e.includes(key)) !== null && _f !== void 0 ? _f : false) === false)
                        return false;
                    return coverStation(components)(visited)(a, b);
                });
            };
        };
    };
    var coverInteger = function (x, y) {
        if (OpenApiTypeChecker.isConstant(y))
            return typeof y.const === "number" && Number.isInteger(y.const);
        return [
            x.type === y.type,
            x.minimum === undefined ||
                (y.minimum !== undefined && x.minimum <= y.minimum),
            x.maximum === undefined ||
                (y.maximum !== undefined && x.maximum >= y.maximum),
            x.exclusiveMinimum !== true ||
                x.minimum === undefined ||
                (y.minimum !== undefined &&
                    (y.exclusiveMinimum === true || x.minimum < y.minimum)),
            x.exclusiveMaximum !== true ||
                x.maximum === undefined ||
                (y.maximum !== undefined &&
                    (y.exclusiveMaximum === true || x.maximum > y.maximum)),
            x.multipleOf === undefined ||
                (y.multipleOf !== undefined &&
                    y.multipleOf / x.multipleOf ===
                        Math.floor(y.multipleOf / x.multipleOf)),
        ].every(function (v) { return v; });
    };
    var coverNumber = function (x, y) {
        if (OpenApiTypeChecker.isConstant(y))
            return typeof y.const === "number";
        return [
            x.type === y.type || (x.type === "number" && y.type === "integer"),
            x.minimum === undefined ||
                (y.minimum !== undefined && x.minimum <= y.minimum),
            x.maximum === undefined ||
                (y.maximum !== undefined && x.maximum >= y.maximum),
            x.exclusiveMinimum !== true ||
                x.minimum === undefined ||
                (y.minimum !== undefined &&
                    (y.exclusiveMinimum === true || x.minimum < y.minimum)),
            x.exclusiveMaximum !== true ||
                x.maximum === undefined ||
                (y.maximum !== undefined &&
                    (y.exclusiveMaximum === true || x.maximum > y.maximum)),
            x.multipleOf === undefined ||
                (y.multipleOf !== undefined &&
                    y.multipleOf / x.multipleOf ===
                        Math.floor(y.multipleOf / x.multipleOf)),
        ].every(function (v) { return v; });
    };
    var coverString = function (x, y) {
        if (OpenApiTypeChecker.isConstant(y))
            return typeof y.const === "string";
        return [
            x.format === undefined ||
                (y.format !== undefined && coverFormat(x.format, y.format)),
            x.pattern === undefined || x.pattern === y.pattern,
            x.minLength === undefined ||
                (y.minLength !== undefined && x.minLength <= y.minLength),
            x.maxLength === undefined ||
                (y.maxLength !== undefined && x.maxLength >= y.maxLength),
        ].every(function (v) { return v; });
    };
    var coverFormat = function (x, y) {
        return x === y ||
            (x === "idn-email" && y === "email") ||
            (x === "idn-hostname" && y === "hostname") ||
            (["uri", "iri"].includes(x) && y === "url") ||
            (x === "iri" && y === "uri") ||
            (x === "iri-reference" && y === "uri-reference");
    };
    var flatSchema = function (components) {
        return function (schema) {
            schema = escapeReference(components)(schema);
            if (OpenApiTypeChecker.isOneOf(schema))
                return schema.oneOf.map(flatSchema(components)).flat();
            return [schema];
        };
    };
    var escapeReference = function (components) {
        return function (schema) {
            return OpenApiTypeChecker.isReference(schema)
                ? escapeReference(components)(components.schemas[schema.$ref.replace("#/components/schemas/", "")])
                : schema;
        };
    };
})(OpenApiTypeChecker || (exports.OpenApiTypeChecker = OpenApiTypeChecker = {}));
