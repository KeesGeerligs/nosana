{"version":3,"file":"HttpLlmFunctionFetcher.mjs","sources":["../../src/http/HttpLlmFunctionFetcher.ts"],"sourcesContent":["import type { HttpLlm } from \"../HttpLlm\";\nimport type { HttpMigration } from \"../HttpMigration\";\nimport { IHttpMigrateRoute } from \"../structures/IHttpMigrateRoute\";\nimport { IHttpResponse } from \"../structures/IHttpResponse\";\nimport { HttpMigrateRouteFetcher } from \"./HttpMigrateRouteFetcher\";\n\nexport namespace HttpLlmFunctionFetcher {\n  export const execute = async (props: HttpLlm.IFetchProps): Promise<unknown> =>\n    HttpMigrateRouteFetcher.execute(getFetchArguments(\"execute\", props));\n\n  export const propagate = async (\n    props: HttpLlm.IFetchProps,\n  ): Promise<IHttpResponse> =>\n    HttpMigrateRouteFetcher.propagate(getFetchArguments(\"propagate\", props));\n\n  const getFetchArguments = (\n    from: string,\n    props: HttpLlm.IFetchProps,\n  ): HttpMigration.IFetchProps => {\n    const route: IHttpMigrateRoute = props.function.route();\n    if (props.application.options.keyword === true) {\n      const input: Record<string, any> = props.arguments[0];\n      const valid: boolean =\n        props.arguments.length === 1 &&\n        typeof input === \"object\" &&\n        input !== null;\n      if (valid === false)\n        throw new Error(\n          `Error on HttpLlmFunctionFetcher.${from}(): keyworded arguments must be an object`,\n        );\n      return {\n        connection: props.connection,\n        route,\n        parameters: Object.fromEntries(\n          route.parameters.map((p) => [p.key, input[p.key]] as const),\n        ),\n        query: input.query,\n        body: input.body,\n      };\n    }\n    const parameters: Array<string | number | boolean | bigint | null> =\n      props.arguments.slice(0, route.parameters.length);\n    const query: object | undefined = route.query\n      ? props.arguments[route.parameters.length]\n      : undefined;\n    const body: object | undefined = route.body\n      ? props.arguments[route.parameters.length + (route.query ? 1 : 0)]\n      : undefined;\n    return {\n      connection: props.connection,\n      route,\n      parameters,\n      query,\n      body,\n    };\n  };\n}\n"],"names":["HttpLlmFunctionFetcher","execute","async","props","HttpMigrateRouteFetcher","getFetchArguments","propagate","from","route","function","application","options","keyword","input","arguments","valid","length","Error","connection","parameters","Object","fromEntries","map","p","key","query","body","slice","undefined"],"mappings":";;AAMM,IAAWA;;CAAjB,SAAiBA;IACFA,uBAAAC,UAAUC,MAAOC,SAC5BC,wBAAwBH,QAAQI,kBAAkB,WAAWF;IAElDH,uBAAAM,YAAYJ,MACvBC,SAEAC,wBAAwBE,UAAUD,kBAAkB,aAAaF;IAEnE,MAAME,oBAAoB,CACxBE,MACAJ;QAEA,MAAMK,QAA2BL,MAAMM,SAASD;QAChD,IAAIL,MAAMO,YAAYC,QAAQC,YAAY,MAAM;YAC9C,MAAMC,QAA6BV,MAAMW,UAAU;YACnD,MAAMC,QACJZ,MAAMW,UAAUE,WAAW,YACpBH,UAAU,YACjBA,UAAU;YACZ,IAAIE,UAAU,OACZ,MAAM,IAAIE,MACR,mCAAmCV;YAEvC,OAAO;gBACLW,YAAYf,MAAMe;gBAClBV;gBACAW,YAAYC,OAAOC,YACjBb,MAAMW,WAAWG,KAAKC,KAAM,EAACA,EAAEC,KAAKX,MAAMU,EAAEC;gBAE9CC,OAAOZ,MAAMY;gBACbC,MAAMb,MAAMa;;AAEf;QACD,MAAMP,aACJhB,MAAMW,UAAUa,MAAM,GAAGnB,MAAMW,WAAWH;QAC5C,MAAMS,QAA4BjB,MAAMiB,QACpCtB,MAAMW,UAAUN,MAAMW,WAAWH,UACjCY;QACJ,MAAMF,OAA2BlB,MAAMkB,OACnCvB,MAAMW,UAAUN,MAAMW,WAAWH,UAAUR,MAAMiB,QAAQ,IAAI,MAC7DG;QACJ,OAAO;YACLV,YAAYf,MAAMe;YAClBV;YACAW;YACAM;YACAC;;AACD;AAEJ,EAlDD,CAAiB1B,2BAAAA,yBAkDhB,CAAA;;"}