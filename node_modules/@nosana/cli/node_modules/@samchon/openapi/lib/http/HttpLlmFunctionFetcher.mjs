import { HttpMigrateRouteFetcher } from "./HttpMigrateRouteFetcher.mjs";

var HttpLlmFunctionFetcher;

(function(HttpLlmFunctionFetcher) {
    HttpLlmFunctionFetcher.execute = async props => HttpMigrateRouteFetcher.execute(getFetchArguments("execute", props));
    HttpLlmFunctionFetcher.propagate = async props => HttpMigrateRouteFetcher.propagate(getFetchArguments("propagate", props));
    const getFetchArguments = (from, props) => {
        const route = props.function.route();
        if (props.application.options.keyword === true) {
            const input = props.arguments[0];
            const valid = props.arguments.length === 1 && typeof input === "object" && input !== null;
            if (valid === false) throw new Error(`Error on HttpLlmFunctionFetcher.${from}(): keyworded arguments must be an object`);
            return {
                connection: props.connection,
                route,
                parameters: Object.fromEntries(route.parameters.map((p => [ p.key, input[p.key] ]))),
                query: input.query,
                body: input.body
            };
        }
        const parameters = props.arguments.slice(0, route.parameters.length);
        const query = route.query ? props.arguments[route.parameters.length] : undefined;
        const body = route.body ? props.arguments[route.parameters.length + (route.query ? 1 : 0)] : undefined;
        return {
            connection: props.connection,
            route,
            parameters,
            query,
            body
        };
    };
})(HttpLlmFunctionFetcher || (HttpLlmFunctionFetcher = {}));

export { HttpLlmFunctionFetcher };
//# sourceMappingURL=HttpLlmFunctionFetcher.mjs.map
