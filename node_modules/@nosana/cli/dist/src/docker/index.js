import Dockerode from 'dockerode';
import { repoTagsContainsImage } from './utils/repoTagsContainsImage.js';
import { MultiProgressBarReporter } from '../services/NodeManager/node/utils/multiProgressBarReporter.js';
import { createLoggingProxy } from '../services/NodeManager/monitoring/proxy/loggingProxy.js';
export class DockerExtended extends Dockerode {
    async promisePull(image) {
        const multiProgressBarReporter = createLoggingProxy(new MultiProgressBarReporter());
        return await new Promise((resolve, reject) => this.pull(image, (err, stream) => {
            if (err) {
                reject(err);
            }
            // const layerIds = new Map<string, SingleBar>();
            // const multibar = new MultiBar(
            //   {
            //     clearOnComplete: false,
            //     hideCursor: true,
            //     format:
            //       '{status} | {bar} | {layerId} | {value}{format}/{total}{format}',
            //   },
            //   Presets.shades_grey,
            // );
            multiProgressBarReporter.start(`pulling image ${image}`, {
                format: '{status} | {bar} | {layerId} | {value}{format}/{total}{format}',
            });
            const onProgress = (event) => {
                multiProgressBarReporter.update(event);
                // const { id, status, progressDetail } = event;
                // if (status === 'Pulling fs layer') return;
                // let progressBar = layerIds.get(id);
                // if (status === 'Downloading') {
                //   const { current, total } = progressDetail;
                //   const { value } = convertFromBytes(current);
                //   const { format, value: totalValue } = convertFromBytes(total);
                //   if (!progressBar) {
                //     progressBar = multibar.create(totalValue, value, {
                //       status,
                //       layerId: id,
                //       format,
                //     });
                //     layerIds.set(id, progressBar);
                //   }
                //   progressBar.update(value, { status });
                //   return;
                // }
                // if (progressBar) {
                //   progressBar.update(progressBar.getTotal(), { status });
                // }
            };
            const onFinished = (err, _) => {
                multiProgressBarReporter.stop(`done pulling image ${image}`);
                if (!err) {
                    resolve(true);
                    return;
                }
                reject(err);
            };
            this.modem.followProgress(stream, (err, output) => onFinished(err, output), onProgress);
        }));
    }
    async hasImage(image) {
        const savedImages = await this.listImages();
        return savedImages.some(({ RepoTags }) => repoTagsContainsImage(image, RepoTags));
    }
}
