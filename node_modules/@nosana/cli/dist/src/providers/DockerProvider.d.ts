import Docker, { Container } from 'dockerode';
import { BasicProvider } from './BasicProvider.js';
import { Operation, Provider, OpState, Flow, OperationArgsMap, OperationResults, OperationType } from './Provider.js';
import { DockerExtended } from '../docker/index.js';
import Logger from './modules/logger/index.js';
export type RunContainerArgs = {
    name?: string;
    networks?: {
        [key: string]: {};
    };
    cmd?: string[];
    gpu?: boolean;
    network_mode?: 'bridge' | 'host' | 'none';
    volumes?: Array<{
        dest: string;
        name: string;
        readonly?: boolean;
    }>;
    env?: {
        [key: string]: string;
    };
    work_dir?: string;
    entrypoint?: string | string[];
    restart_policy?: '' | 'unless-stopped' | 'always' | 'on-failure';
};
export declare const FRPC_IMAGE = "registry.hub.docker.com/nosana/frpc:0.1.0";
export declare class DockerProvider extends BasicProvider implements Provider {
    docker: DockerExtended;
    protected resourceManager: import("./modules/resourceManager/index.js").ResourceManager;
    host: string;
    port: string;
    protocol: 'https' | 'http' | 'ssh';
    name: string;
    gpu: string;
    constructor(server: string, configLocation: string, gpu: string, logger?: Logger);
    getContainer(id: string): Promise<Docker.Container>;
    /**
     * Check if DockerProvider is healthy by checking if podman is running
     * @returns boolean
     */
    healthy(throwError?: Boolean): Promise<Boolean>;
    /**
     * Create the containers neccesary for a container/run operation.
     * Returns the main container
     * @param opArgs
     * @param flowId
     * @param opStateIndex
     * @param updateOpState
     * @returns
     */
    runOpContainerRun(opArgs: OperationArgsMap['container/run'], flowId: string, opStateIndex: number, updateOpState: Function): Promise<Container>;
    runContainer(image: string, { name, networks, cmd, gpu, volumes, env, work_dir, network_mode, entrypoint, restart_policy, }: RunContainerArgs): Promise<Container>;
    protected hookPreRun(flow: Flow): Flow;
    stopFlowOperation(flowId: string, op: Operation<OperationType>): Promise<OpState>;
    /**
     * Finish container run, extract results and update opState
     * @param container
     * @param opState
     * @param containerInfo optional
     */
    protected finishOpContainerRun({ container, containerInfo, operationResults, updateOpState, }: {
        container: Docker.Container;
        containerInfo?: Docker.ContainerInspectInfo;
        operationResults?: OperationResults | undefined;
        updateOpState: Function;
    }): Promise<void>;
    finishFlow(flowId: string, status?: string | undefined): Promise<void>;
    updateMarketRequiredResources(market: string): Promise<void>;
    /****************
     *   Helpers   *
     ****************/
    pullImage(image: string): Promise<true | undefined>;
    /**
     * Remove volume
     * @returns
     */
    private removeVolume;
    stopAndRemoveContainer(containerId: string): Promise<void>;
    private streamingLogs;
}
