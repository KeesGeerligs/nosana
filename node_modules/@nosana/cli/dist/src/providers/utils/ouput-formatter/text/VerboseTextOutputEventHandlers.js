import { OUTPUT_EVENTS, } from '../outputEvents.js';
import chalk from 'chalk';
import { colors } from '../../../../generic/utils.js';
import figlet from 'figlet';
export const verboseTextOutputEventHandlers = {
    [OUTPUT_EVENTS.READ_KEYFILE]: (param) => {
        console.log(`Reading keypair from ${colors.CYAN}${param.keyfile}${colors.RESET}\n`);
    },
    [OUTPUT_EVENTS.CREATE_KEYFILE]: (param) => {
        console.log(`Creating new keypair and storing it in ${colors.CYAN}${param.keyfile}${colors.RESET}\n`);
    },
    [OUTPUT_EVENTS.OUTPUT_BALANCES]: (param) => {
        console.log(`SOL balance:\t${colors.GREEN}${param.sol} SOL${colors.RESET}`);
        console.log(`NOS balance:\t${colors.GREEN}${param.nos} NOS${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_NETWORK]: (param) => {
        console.log(`Network:\t${colors.GREEN}${param.network}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_WALLET]: (param) => {
        console.log(`Wallet:\t\t${colors.GREEN}${param.publicKey}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_IPFS_UPLOADED]: (param) => {
        console.log(`ipfs uploaded:\t${colors.BLUE}${param.ipfsHash}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_SERVICE_URL]: (param) => {
        console.log(chalk.cyan(`Service will be exposed at ${chalk.bold(`${param.url}`)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_PRIVATE_URL_MESSAGE]: (param) => {
        console.log(chalk.cyan(`this servcie exposed url is private you can access it once a node picks up this job via the command: ${chalk.bold(param.command)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_SERVICE_URL]: (param) => {
        console.log(`Node:\t${colors.GREEN}${param.url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_INVALID]: () => {
        console.error(chalk.red('Invalid job entered'));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL_EXPIRED]: (param) => {
        console.error(chalk.red(`Job exposed URL is expired since Job has been ${param.state}`));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL_NOT_READY]: () => {
        console.error(chalk.red('Job exposed URL is not ready yet'));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL_ERROR]: (param) => {
        throw new Error(`Failed to fetch exposed URL \n${param.error.message}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL]: (param) => {
        console.log(`Job:\t\t${colors.BLUE}${param.job_url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JSON_FLOW_URL]: (param) => {
        console.log(`JSON flow:\t${colors.BLUE}${param.json_flow_url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_MARKET_URL]: (param) => {
        console.log(`Market:\t\t${colors.BLUE}${param.market_url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_PRICE]: (param) => {
        console.log(`Price:\t\t${colors.CYAN}${param.price} NOS/s${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_TOTAL_COST]: (param) => {
        console.log(`Total Costs:\t${colors.CYAN}${param.cost} NOS${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_STATUS]: (param) => {
        console.log(`Status:\t\t${param.status === 'COMPLETED' ? colors.GREEN : colors.CYAN}${param.status}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_POSTING]: (param) => {
        console.log(`posting job to market ${colors.CYAN}${param.market_address}${colors.RESET} for price ${colors.YELLOW}${param.price} NOS/s${colors.RESET} (total: ${param.total} NOS)`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_POSTED_TX]: (param) => {
        console.log(`job posted with tx ${chalk.cyan(param.tx)}!`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_VALIDATION_ERROR]: (param) => {
        console.error(param.error);
        throw new Error(chalk.red.bold('Job Definition validation failed'));
    },
    [OUTPUT_EVENTS.OUTPUT_FAILED_TO_FETCH_MARKETS_ERROR]: (param) => {
        throw new Error(`Failed to fetch market \n${param.error.message}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_POSTED_ERROR]: (param) => {
        console.error(chalk.red("Couldn't post job"));
        throw param;
    },
    [OUTPUT_EVENTS.OUTPUT_SOL_BALANCE_LOW_ERROR]: (param) => {
        throw new Error(chalk.red(`Minimum of ${chalk.bold('0.005')} SOL needed: SOL available ${chalk.bold(param.sol)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_NOS_BALANCE_LOW_ERROR]: (param) => {
        throw new Error(chalk.red(`Not enough NOS: NOS available ${chalk.bold(param.nosBalance)}, NOS needed: ${chalk.bold(param.nosNeeded)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_AIRDROP_REQUEST_FAILED_ERROR]: (param) => {
        throw new Error('Couldnt airdrop tokens to your address');
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_NOT_FOUND]: (param) => {
        console.error(`${colors.RED}Could not retrieve job\n${colors.RESET}`, param.error);
    },
    [OUTPUT_EVENTS.OUTPUT_CANNOT_LOG_RESULT]: () => {
        console.log(`${colors.RED}Cannot log results${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_ARTIFACT_SUPPORT_INCOMING_ERROR]: (param) => {
        throw new Error('artifact support coming soon!');
    },
    [OUTPUT_EVENTS.OUTPUT_JSON_FLOW_TYPE_NOT_SUPPORTED_ERROR]: (param) => {
        throw new Error(`type ${param.type} not supported yet`);
    },
    [OUTPUT_EVENTS.OUTPUT_NODE_URL]: (param) => {
        console.log(`Node:\t\t${colors.BLUE}${param.url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_DURATION]: (param) => {
        console.log(`Duration:\t${colors.CYAN}${param.duration} seconds${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_START_TIME]: (param) => {
        console.log(`Start Time:\t${colors.CYAN}${param.date}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_RESULT_URL]: (param) => {
        console.log(`Result:\t\t${colors.BLUE}${param.url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_RETRIVE_JOB_COMMAND]: (param) => {
        console.log(`\nrun ${colors.CYAN}nosana job get ${param.job} --network ${param.network}${colors.RESET} to retrieve job and result`);
    },
    [OUTPUT_EVENTS.OUTPUT_HEADER_LOGO]: (param) => {
        console.log(figlet.textSync(param.text));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_EXECUTION]: (param) => {
        console.log('Logs:');
        console.log(`\n${colors.CYAN}- Executed step ${param.opState.operationId} in ${(param.opState.endTime - param.opState.startTime) / 1000}s${colors.RESET}\n`);
        for (const log of param.opState.logs) {
            const color = log.type === 'stderr' && param.opState.exitCode ? colors.RED : '';
            const sanitizedLog = log.log;
            console.log(`${color}${sanitizedLog}${colors.RESET}`);
        }
        if (param.opState.status) {
            console.log(`\n${param.opState.exitCode ? colors.RED : colors.GREEN}Exited with status ${param.opState.status} with code ${param.opState.exitCode} ${colors.RESET}`);
        }
    },
};
