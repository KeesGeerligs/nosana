import { OUTPUT_EVENTS, } from '../outputEvents.js';
import chalk from 'chalk';
import { colors } from '../../../../generic/utils.js';
import figlet from 'figlet';
function mapToDoNothingFunction(events) {
    return events.reduce((handlers, event) => {
        handlers[event] = () => { };
        return handlers;
    }, {});
}
export const textOutputEventHandlers = {
    /**
     * This is where we dump the event that you want to do nothing
     * this is so you do not forget to integrate them and create error
     */
    ...mapToDoNothingFunction([
        OUTPUT_EVENTS.OUTPUT_IPFS_UPLOADED,
        OUTPUT_EVENTS.OUTPUT_JSON_FLOW_URL,
        OUTPUT_EVENTS.OUTPUT_JOB_PRICE,
        OUTPUT_EVENTS.OUTPUT_JOB_POSTING,
        OUTPUT_EVENTS.OUTPUT_JOB_POSTED_TX,
        OUTPUT_EVENTS.OUTPUT_RESULT_URL,
        OUTPUT_EVENTS.OUTPUT_JOB_EXECUTION,
    ]),
    [OUTPUT_EVENTS.OUTPUT_SERVICE_URL]: (param) => {
        console.log(chalk.cyan(`Service will be exposed at ${chalk.bold(`${param.url}`)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_PRIVATE_URL_MESSAGE]: (param) => {
        console.log(chalk.cyan(`this servcie exposed url is private and will be available when a node picks up this job`));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_SERVICE_URL]: (param) => {
        console.log(`URL:\t\t${colors.GREEN}${param.url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_INVALID]: () => {
        console.error(chalk.red('Invalid job entered'));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL_EXPIRED]: (param) => {
        console.error(chalk.red(`Job exposed URL is expired since Job has been ${param.state}`));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL_NOT_READY]: () => {
        console.error(chalk.red('Job exposed URL is not ready yet'));
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL_ERROR]: (param) => {
        throw new Error(`Failed to fetch exposed URL \n${param.error.message}`);
    },
    [OUTPUT_EVENTS.READ_KEYFILE]: (param) => {
        console.log(`Reading keypair from ${colors.CYAN}${param.keyfile}${colors.RESET}\n`);
    },
    [OUTPUT_EVENTS.CREATE_KEYFILE]: (param) => {
        console.log(`Creating new keypair and storing it in ${colors.CYAN}${param.keyfile}${colors.RESET}\n`);
    },
    [OUTPUT_EVENTS.OUTPUT_BALANCES]: (param) => {
        console.log(`SOL balance:\t${colors.GREEN}${param.sol} SOL${colors.RESET}`);
        console.log(`NOS balance:\t${colors.GREEN}${param.nos} NOS${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_NETWORK]: (param) => {
        console.log(`Network:\t${colors.GREEN}${param.network}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_WALLET]: (param) => {
        console.log(`Wallet:\t\t${colors.GREEN}${param.publicKey}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_URL]: (param) => {
        console.log(`Job:\t\t${colors.BLUE}${param.job_url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_MARKET_URL]: (param) => {
        console.log(`Market:\t\t${colors.BLUE}${param.market_url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_TOTAL_COST]: (param) => {
        console.log(`Total Costs:\t${colors.CYAN}${param.cost} NOS${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_STATUS]: (param) => {
        console.log(`Status:\t\t${param.status === 'COMPLETED' ? colors.GREEN : colors.CYAN}${param.status}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_VALIDATION_ERROR]: (param) => {
        console.error(param.error);
        throw new Error(chalk.red.bold('Job Definition validation failed'));
    },
    [OUTPUT_EVENTS.OUTPUT_FAILED_TO_FETCH_MARKETS_ERROR]: (param) => {
        throw new Error(`Failed to fetch market \n${param.error.message}`);
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_POSTED_ERROR]: (param) => {
        console.error(chalk.red("Couldn't post job"));
        throw param;
    },
    [OUTPUT_EVENTS.OUTPUT_SOL_BALANCE_LOW_ERROR]: (param) => {
        throw new Error(chalk.red(`Minimum of ${chalk.bold('0.005')} SOL needed: SOL available ${chalk.bold(param.sol)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_NOS_BALANCE_LOW_ERROR]: (param) => {
        throw new Error(chalk.red(`Not enough NOS: NOS available ${chalk.bold(param.nosBalance)}, NOS needed: ${chalk.bold(param.nosNeeded)}`));
    },
    [OUTPUT_EVENTS.OUTPUT_AIRDROP_REQUEST_FAILED_ERROR]: (param) => {
        throw new Error('Couldnt airdrop tokens to your address');
    },
    [OUTPUT_EVENTS.OUTPUT_JOB_NOT_FOUND]: (param) => {
        console.error(`${colors.RED}Could not retrieve job\n${colors.RESET}`, param.error);
    },
    [OUTPUT_EVENTS.OUTPUT_CANNOT_LOG_RESULT]: () => {
        console.log(`${colors.RED}Cannot log results${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_ARTIFACT_SUPPORT_INCOMING_ERROR]: (param) => {
        throw new Error('artifact support coming soon!');
    },
    [OUTPUT_EVENTS.OUTPUT_JSON_FLOW_TYPE_NOT_SUPPORTED_ERROR]: (param) => {
        throw new Error(`type ${param.type} not supported yet`);
    },
    [OUTPUT_EVENTS.OUTPUT_NODE_URL]: (param) => {
        console.log(`Node:\t\t${colors.BLUE}${param.url}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_DURATION]: (param) => {
        console.log(`Duration:\t${colors.CYAN}${param.duration} seconds${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_START_TIME]: (param) => {
        console.log(`Start Time:\t${colors.CYAN}${param.date}${colors.RESET}`);
    },
    [OUTPUT_EVENTS.OUTPUT_RETRIVE_JOB_COMMAND]: (param) => {
        console.log(`\nrun ${colors.CYAN}nosana job get ${param.job} --network ${param.network}${colors.RESET} to retrieve job and result`);
    },
    [OUTPUT_EVENTS.OUTPUT_HEADER_LOGO]: (param) => {
        console.log(figlet.textSync(param.text));
    },
};
