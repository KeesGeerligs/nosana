import fs from 'node:fs';
import chalk from 'chalk';
import ora from 'ora';
import util from 'util';
import { ProviderEvents, } from '../../../providers/Provider.js';
import { NosanaNode } from '../../../services/NosanaNode.js';
import { Client } from '@nosana/sdk';
let flow;
let node;
export async function runJob(jobDefinitionFile, options) {
    let handlingSigInt = false;
    const onShutdown = async () => {
        if (!handlingSigInt) {
            handlingSigInt = true;
            console.log(chalk.yellow.bold('Shutting down..'));
            if (node) {
                await node.shutdown();
            }
            if (flow) {
                const spinner = ora(chalk.cyan(`Stopping flow ${flow.id}`)).start();
                try {
                    await node.provider.stopFlow(flow.id);
                    await node.provider.waitForFlowFinish(flow.id);
                    spinner.succeed(chalk.green(`Flow succesfully stopped`));
                }
                catch (e) {
                    spinner.fail(chalk.red.bold('Could not stop flow'));
                    throw e;
                }
            }
            handlingSigInt = false;
            process.exit();
        }
    };
    process.on('SIGINT', onShutdown);
    process.on('SIGTERM', onShutdown);
    let spinner = ora();
    let streamingLogs = false;
    node = new NosanaNode(new Client(), // sdk client not used during `node run`
    options.provider, options.podman, options.config, options.gpu);
    node.logger.override(ProviderEvents.INFO_LOG, (event) => {
        if (!handlingSigInt) {
            if (event.type === 'info' && event.pending && streamingLogs) {
                // If we want to start a spinner during streamingLogs, disable it
                event.pending = false;
            }
            node.logger.standard_info_log(event, spinner);
        }
    });
    spinner = ora(chalk.cyan('Checking provider health')).start();
    try {
        await node.provider.healthy();
    }
    catch (error) {
        spinner.fail(chalk.red(`${chalk.bold(options.provider)} provider not healthy`));
        throw error;
    }
    spinner.succeed(chalk.green(`${chalk.bold(node.provider.name)} is running on ${chalk.bold(`${node.provider.protocol}://${node.provider.host}:${node.provider.port}`)}`));
    let jobDefinition;
    if (options.url) {
        try {
            const data = await fetch(options.url);
            const json = await data.json();
            jobDefinition = json;
        }
        catch (e) {
            throw new Error(`Failed to fetch remote job flow.\n${e}`);
        }
    }
    else {
        if (!jobDefinitionFile) {
            throw new Error('Missing Job Definition Argument');
        }
        jobDefinition = JSON.parse(fs.readFileSync(jobDefinitionFile, 'utf8'));
    }
    let result = null;
    try {
        flow = node.provider.run(jobDefinition);
        const isFlowExposed = jobDefinition.ops.filter((op) => op.type === 'container/run' &&
            op.args.expose).length > 0;
        streamingLogs = true;
        result = await node.provider.waitForFlowFinish(flow.id, (event) => {
            if (!handlingSigInt && !isFlowExposed) {
                if (event.type === 'stdout') {
                    process.stdout.write(event.log);
                }
                else {
                    process.stderr.write(event.log);
                }
            }
        });
        streamingLogs = false;
        console.log('result: ', util.inspect(result, { showHidden: false, depth: null, colors: true }));
    }
    catch (error) {
        spinner.fail(chalk.red.bold(error));
    }
    if (node.provider.clearFlowsCronJob) {
        node.provider.clearFlowsCronJob.stop();
    }
}
