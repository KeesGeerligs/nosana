import { ProviderEvents } from '../providers/Provider.js';
import { subscribe as NodeSubscribe } from './state/node/subscribe.js';
import { subscribe as JobSubscribe } from './state/job/subscribe.js';
export default class LogSubscriberManager {
    constructor() {
        this.subscribers = new Set();
        this.eventIndex = 0;
        this.events = new Map();
        this.lastProcessedLogIndex = -1;
        this.logStatusClients = [];
    }
    subscribe(callback) {
        this.subscribers.add(callback);
    }
    unsubscribe(callback) {
        this.subscribers.delete(callback);
    }
    addClient(response, jobId, logType) {
        this.logStatusClients.push({ response, jobId, logType });
        const events = this.getEvents(jobId, logType);
        if (events.length > 0) {
            response.write(`data: ${JSON.stringify(events)}\n\n`);
        }
        // TODO: FIX AS THIS DOES NOT GET CALLED
        response.on('close', () => {
            this.removeClient(response);
        });
    }
    removeClient(response) {
        const index = this.logStatusClients.findIndex((client) => client.response === response);
        if (index !== -1) {
            this.logStatusClients = this.logStatusClients.splice(index, 1);
        }
    }
    notifySubscribers(log) {
        this.addEvent(log.job, log);
        this.subscribers.forEach((callback) => callback(log));
        this.logStatusClients.forEach(({ jobId, response, logType }) => {
            if (log.job === jobId) {
                if (!logType || logType === log.event) {
                    response.write(`data: ${JSON.stringify([log])}\n\n`);
                }
            }
        });
    }
    getCurrentJob(node) {
        const run = node.run;
        if (run) {
            return run.account.job.toString();
        }
        return 'default';
    }
    getEvents(jobId, logType) {
        let events = this.events.get(jobId) || [];
        if (logType)
            events = events.filter(({ event }) => event === logType);
        return events;
    }
    addEvent(jobId, log) {
        this.events.set(jobId, this.getEvents(jobId).concat([log]));
    }
    getEventIndex() {
        return this.eventIndex;
    }
    incrementEventIndex() {
        this.eventIndex++;
    }
    listenToLoggerEvents(logger, node) {
        JobSubscribe((entry) => {
            this.notifySubscribers({
                log: JSON.stringify(entry),
                pending: false,
                type: '',
                job: this.getCurrentJob(node),
                index: this.getEventIndex(),
                event: 'jobLog',
            });
            this.incrementEventIndex();
        });
        NodeSubscribe((entry) => {
            this.notifySubscribers({
                log: JSON.stringify(entry),
                pending: false,
                type: '',
                job: '',
                index: this.getEventIndex(),
                event: 'nodeLog',
            });
            this.incrementEventIndex();
        });
        logger.on(ProviderEvents.INFO_LOG, (event) => {
            this.notifySubscribers({
                ...event,
                event: ProviderEvents.INFO_LOG,
                index: this.getEventIndex(),
                job: this.getCurrentJob(node),
            });
            this.incrementEventIndex();
        });
        logger.on(ProviderEvents.CONTAINER_LOG, (event) => {
            this.notifySubscribers({
                ...event,
                event: ProviderEvents.CONTAINER_LOG,
                index: this.getEventIndex(),
                job: this.getCurrentJob(node),
            });
            this.incrementEventIndex();
        });
    }
    handleRemoteLogEvents(events, logger) {
        events.sort((a, b) => a.index - b.index);
        events.forEach((event) => {
            if (event.index >= this.lastProcessedLogIndex + 1) {
                if (event.event === ProviderEvents.INFO_LOG) {
                    logger.standard_info_log({
                        log: event.log,
                        pending: false,
                        type: event.type,
                    });
                }
                if (event.event === ProviderEvents.CONTAINER_LOG) {
                    process.stdout.write(event.log);
                }
                this.lastProcessedLogIndex = event.index;
            }
        });
    }
}
