import WebSocket from 'ws';
import { state } from '../state/NodeState.js';
export const stateStreaming = (() => {
    let instance = null;
    return (node) => {
        if (!instance) {
            instance = new StateStreamer(node);
        }
        return instance;
    };
})();
export class StateStreamer {
    constructor(node) {
        this.states = new Map();
        this.index = 0;
        this.clients = new Map();
        state(node).addObserver(this);
    }
    clear() {
        this.states.clear();
    }
    update(status, state, timestamp) {
        const stateMessage = JSON.stringify({
            status,
            state,
            timestamp,
            index: this.index,
        });
        this.index = this.index + 1;
        if (state.job) {
            this.states.set(state.job, (this.states.get(state.job) ?? []).concat([stateMessage]));
            const clients = this.clients.get(state.job) ?? [];
            clients.forEach((ws) => {
                ws.send(JSON.stringify({ data: stateMessage, path: 'state' }));
            });
        }
        this.states.set('all', (this.states.get('all') ?? []).concat([stateMessage]));
    }
    subscribe(ws, job) {
        this.clients.set(job, (this.clients.get(job) ?? []).concat([ws]));
        const states = this.states.get(job) ?? [];
        states.forEach((state) => {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ data: state, path: 'state' }));
            }
        });
    }
    unsubscribe(ws) {
        for (const [job, clients] of this.clients) {
            const updatedClients = clients.filter((client) => client !== ws);
            if (updatedClients.length > 0) {
                this.clients.set(job, updatedClients);
            }
            else {
                this.clients.delete(job);
            }
        }
    }
}
