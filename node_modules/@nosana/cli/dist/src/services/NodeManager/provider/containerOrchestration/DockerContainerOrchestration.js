import { DockerExtended } from '../../../../docker/index.js';
import { createSeverObject } from '../../../../providers/utils/createServerObject.js';
export class DockerContainerOrchestration {
    constructor(server, gpu) {
        this.name = 'docker';
        this.gpu = 'all';
        const { host, port, protocol } = createSeverObject(server);
        this.host = host;
        this.port = port;
        this.protocol = protocol;
        this.gpu = gpu;
        this.docker = new DockerExtended({
            host: this.host,
            port: this.port,
            protocol: this.protocol,
        });
    }
    async getContainersByName(names) {
        try {
            const containers = await this.docker.listContainers({ all: true });
            const matchedContainers = containers.filter((container) => names.some((name) => container.Names.includes(`/${name}`)));
            if (matchedContainers.length > 0) {
                const containerObjects = matchedContainers.map((containerInfo) => this.docker.getContainer(containerInfo.Id));
                return containerObjects;
            }
            else {
                return [];
            }
        }
        catch (_) {
            throw new Error('could not get containers');
        }
    }
    getConnection() {
        return this.docker;
    }
    async pullImage(image) {
        if (await this.docker.hasImage(image)) {
            return { status: true };
        }
        try {
            await this.docker.promisePull(image);
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async hasImage(image) {
        if (await this.docker.hasImage(image)) {
            return true;
        }
        return false;
    }
    async getImage(image) {
        return this.docker.getImage(image);
    }
    async listImages() {
        return this.docker.listImages();
    }
    async deleteImage(image) {
        try {
            if (await this.docker.hasImage(image)) {
                await this.docker.getImage(image).remove({ force: true });
            }
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async createNetwork(name) {
        try {
            await this.docker.createNetwork({ Name: name });
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async hasNetwork(name) {
        const networks = await this.docker.listNetworks();
        return networks.some((network) => network.Name === name);
    }
    async deleteNetwork(name) {
        try {
            await this.docker.getNetwork(name).remove();
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async createVolume(name) {
        try {
            const volume = await this.docker.createVolume({ Name: name });
            return { status: true, result: volume };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async hasVolume(name) {
        try {
            const volumes = await this.docker.listVolumes();
            return volumes.Volumes.some((volume) => volume.Name === name);
        }
        catch (error) {
            return false;
        }
    }
    async listVolumes() {
        return (await this.docker.listVolumes()).Volumes;
    }
    async getVolume(name) {
        try {
            const volume = this.docker.getVolume(name);
            return { status: true, result: volume };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async getRawVolume(name) {
        return this.docker.getVolume(name);
    }
    async deleteVolume(name) {
        try {
            const volume = this.docker.getVolume(name);
            if (volume) {
                await this.docker.getVolume(name).remove({ force: true });
            }
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async healthy() {
        try {
            const info = await this.docker.info();
            if (typeof info === 'object' && info !== null && info.ID) {
                return { status: true };
            }
            return { status: false, error: new Error('invalid docker info') };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async getContainer(id) {
        const container = this.docker.getContainer(id);
        return container;
    }
    async runContainer(args) {
        try {
            const container = await this.docker.createContainer(args);
            await container.start();
            return { status: true, result: container };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async runFlowContainer(image, args) {
        try {
            const container = await this.docker.createContainer(mapRunContainerArgsToContainerCreateOpts(image, args, this.gpu));
            await container.start();
            console.log(container);
            return { status: true, result: container };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async stopContainer(id) {
        try {
            const container = this.docker.getContainer(id);
            if (container.id) {
                let containerInfo;
                try {
                    containerInfo = await container.inspect();
                }
                catch (error) { }
                if (containerInfo) {
                    if (containerInfo.State.Status !== 'exited') {
                        this.docker.getContainer(id).stop();
                    }
                }
            }
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async stopAndDeleteContainer(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            if (container.id) {
                let info;
                try {
                    info = await container.inspect();
                }
                catch (error) { }
                if (info) {
                    try {
                        await container.stop();
                    }
                    catch (error) { }
                    try {
                        await container.remove({ force: true });
                    }
                    catch (error) { }
                }
            }
            return { status: true };
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async isContainerExited(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            let containerInfo;
            try {
                containerInfo = await container.inspect();
            }
            catch (error) { }
            if (containerInfo) {
                return { status: true, result: containerInfo.State.Status == 'exited' };
            }
            else {
                return { status: true, result: true };
            }
        }
        catch (error) {
            return { status: false, error };
        }
    }
    async doesContainerExist(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            await container.inspect();
            return { status: true, result: true };
        }
        catch (error) {
            if (error.statusCode === 404) {
                return { status: true, result: false };
            }
            else {
                return { status: false, error };
            }
        }
    }
    async check() {
        const { status, error } = await this.healthy();
        if (!status) {
            throw new Error(`error on container orchestration (docker or podman), error: ${error}`);
        }
        return `${this.protocol}://${this.host}:${this.port}`;
    }
}
function mapRunContainerArgsToContainerCreateOpts(image, { name, networks, cmd, gpu, volumes, env, work_dir, network_mode, entrypoint, }, gpuOption) {
    const devices = gpu
        ? [
            {
                ...(gpuOption === 'all'
                    ? { Count: -1 }
                    : { device_ids: gpuOption.split(',') }),
                Driver: 'nvidia',
                Capabilities: [['gpu']],
            },
        ]
        : [];
    const dockerVolumes = [];
    if (volumes && volumes.length > 0) {
        for (let i = 0; i < volumes.length; i++) {
            const volume = volumes[i];
            dockerVolumes.push({
                Target: volume.dest,
                Source: volume.name,
                Type: 'volume',
                ReadOnly: volume.readonly || false,
            });
        }
    }
    const vars = [];
    if (env) {
        for (const [key, value] of Object.entries(env)) {
            vars.push(`${key}=${value}`);
        }
    }
    return {
        name: name,
        Hostname: '',
        User: '',
        AttachStdin: false,
        AttachStdout: true,
        AttachStderr: true,
        Tty: false,
        OpenStdin: false,
        StdinOnce: false,
        Env: vars,
        Cmd: cmd,
        Image: image,
        WorkingDir: work_dir,
        Entrypoint: entrypoint,
        NetworkingConfig: {
            EndpointsConfig: networks,
        },
        HostConfig: {
            Mounts: dockerVolumes,
            NetworkMode: network_mode || 'bridge',
            DeviceRequests: devices,
        },
    };
}
