import { Container, ContainerCreateOptions, ImageInfo, Image, Volume, VolumeCreateResponse, VolumeInspectInfo } from 'dockerode';
import { DockerExtended } from '../../../../docker/index.js';
import { ContainerOrchestrationInterface, RunContainerArgs } from './interface.js';
import { ReturnedStatus } from '../types.js';
export declare class DockerContainerOrchestration implements ContainerOrchestrationInterface {
    docker: DockerExtended;
    host: string;
    port: string;
    protocol: 'https' | 'http' | 'ssh';
    name: string;
    gpu: string;
    constructor(server: string, gpu: string);
    getContainersByName(names: string[]): Promise<Container[]>;
    getConnection(): DockerExtended;
    pullImage(image: string): Promise<ReturnedStatus>;
    hasImage(image: string): Promise<boolean>;
    getImage(image: string): Promise<Image>;
    listImages(): Promise<ImageInfo[]>;
    deleteImage(image: string): Promise<ReturnedStatus>;
    createNetwork(name: string): Promise<ReturnedStatus>;
    hasNetwork(name: string): Promise<boolean>;
    deleteNetwork(name: string): Promise<ReturnedStatus>;
    createVolume(name?: string): Promise<ReturnedStatus<VolumeCreateResponse>>;
    hasVolume(name: string): Promise<boolean>;
    listVolumes(): Promise<VolumeInspectInfo[]>;
    getVolume(name: string): Promise<ReturnedStatus<Volume>>;
    getRawVolume(name: string): Promise<Volume>;
    deleteVolume(name: string): Promise<ReturnedStatus>;
    healthy(): Promise<ReturnedStatus>;
    getContainer(id: string): Promise<Container>;
    runContainer(args: ContainerCreateOptions): Promise<ReturnedStatus<Container>>;
    runFlowContainer(image: string, args: RunContainerArgs): Promise<ReturnedStatus<Container>>;
    stopContainer(id: string): Promise<ReturnedStatus>;
    stopAndDeleteContainer(containerId: string): Promise<ReturnedStatus>;
    isContainerExited(containerId: string): Promise<ReturnedStatus<boolean>>;
    doesContainerExist(containerId: string): Promise<ReturnedStatus<boolean>>;
    check(): Promise<string>;
}
