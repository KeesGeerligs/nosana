export class RunHandler {
    constructor(sdk) {
        this.sdk = sdk;
        this.address = this.sdk.solana.provider.wallet.publicKey;
    }
    getRun() {
        return this.run;
    }
    setRun(run) {
        this.run = run;
    }
    clearRun() {
        this.run = undefined;
    }
    async stopRun() {
        if (this.run) {
            try {
                await this.sdk.jobs.quit(this.run);
            }
            catch (e) {
                return false;
            }
        }
        return true;
    }
    async checkRun() {
        const runs = await this.sdk.jobs.getRuns([
            {
                memcmp: {
                    offset: 40,
                    bytes: this.address.toString(),
                },
            },
        ]);
        if (!runs?.length) {
            this.clearRun();
            return this.getRun();
        }
        this.setRun(runs[0]);
        return this.getRun();
    }
    // Start monitoring run status
    async startRunMonitoring(callback) {
        return new Promise(async (resolve, reject) => {
            try {
                await this.sdk.jobs.loadNosanaJobs();
                const jobProgram = this.sdk.jobs.jobs;
                const runAccountFilter = jobProgram.coder.accounts.memcmp(jobProgram.account.runAccount.idlAccount.name, undefined);
                const coderFilters = [
                    {
                        memcmp: {
                            offset: runAccountFilter.offset,
                            bytes: runAccountFilter.bytes,
                        },
                    },
                    {
                        memcmp: {
                            offset: 40,
                            bytes: this.address.toBase58(), // Convert PublicKey to a string
                        },
                    },
                ];
                // Set up real-time listener for run status changes
                this.runSubscriptionId =
                    this.sdk.jobs.connection.onProgramAccountChange(jobProgram.programId, async (event) => {
                        const runAccount = jobProgram.coder.accounts.decode(jobProgram.account.runAccount.idlAccount.name, event.accountInfo.data);
                        const run = {
                            account: runAccount,
                            publicKey: event.accountId,
                        };
                        resolve(run);
                    }, 'confirmed', coderFilters);
                // Set interval to check run status every 5 minutes
                this.getRunsInterval = setInterval(async () => {
                    let run;
                    try {
                        const health = await callback();
                        if (!health) {
                            reject(new Error('HealthCheck failed'));
                        }
                        run = await this.checkRun();
                        if (run) {
                            resolve(run);
                        }
                    }
                    catch (error) {
                        reject(error);
                    }
                }, 60000 * 5);
                let run;
                try {
                    run = await this.checkRun();
                    if (run) {
                        resolve(run);
                    }
                }
                catch (error) {
                    reject(error);
                }
            }
            catch (error) {
                reject(error);
            }
        });
    }
    // Stop monitoring run status
    stopRunMonitoring() {
        if (this.getRunsInterval) {
            clearInterval(this.getRunsInterval);
            this.getRunsInterval = undefined;
        }
        if (this.runSubscriptionId !== undefined) {
            this.sdk.jobs.connection.removeProgramAccountChangeListener(this.runSubscriptionId);
            this.runSubscriptionId = undefined;
        }
    }
    async stop() {
        this.stopRunMonitoring();
        await this.stopRun();
        this.clearRun();
    }
}
