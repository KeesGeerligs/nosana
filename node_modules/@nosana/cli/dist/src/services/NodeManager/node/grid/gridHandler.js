import { applyLoggingProxyToClass } from '../../monitoring/proxy/loggingProxy.js';
import { VersionedTransaction, } from '@solana/web3.js';
import { getRawTransaction } from '../../../sdk.js';
import { sleep } from '../../../../generic/utils.js';
import { configs } from '../../configs/configs.js';
export class GridHandler {
    constructor(sdk, repository) {
        this.sdk = sdk;
        this.repository = repository;
        this.address = this.sdk.solana.provider.wallet.publicKey;
        applyLoggingProxyToClass(this);
    }
    async getAuthSignature() {
        const signature = (await this.sdk.solana.signMessage(configs().signMessage));
        return Buffer.from(signature).toString('base64');
    }
    async getNodeStatus() {
        try {
            const response = await fetch(`${configs().backendUrl}/nodes/${this.address}`, {
                method: 'GET',
                headers: {
                    Authorization: `${this.address}:${await this.getAuthSignature()}`,
                    'Content-Type': 'application/json',
                },
            });
            const data = await response.json();
            if (!data || (data.name === 'Error' && data.message))
                throw new Error(data.message);
            return {
                status: data.status,
                market: data.marketAddress,
            };
        }
        catch (error) {
            if (error instanceof Error &&
                error.message.includes('Node not onboarded yet')) {
                throw new Error('Node is still on the waitlist, wait until you are accepted.');
            }
            else if (error instanceof Error &&
                error.message.includes('Node not found')) {
                throw new Error('Node is not registred yet. To register run the `node join` command.');
            }
            throw error;
        }
    }
    async recommend() {
        const gpus = this.repository.getNodeInfo().gpus;
        const signature = await this.getAuthSignature();
        try {
            const response = await fetch(`${configs().backendUrl}/nodes/${this.address}/check-market`, {
                method: 'POST',
                headers: {
                    Authorization: `${this.address}:${signature}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ gpus: JSON.stringify(gpus) }),
            });
            let data = await response.json();
            if (!data) {
                throw new Error('Something went wrong with recommending the market, please try again.');
            }
            if (data.needsChangeMarket) {
                data = await this.changeMarket();
                return data.newMarket;
            }
            if (data.address) {
                return data.address;
            }
            if (data.message) {
                throw new Error(data.message);
            }
        }
        catch (error) {
            throw error;
        }
    }
    async changeMarket() {
        try {
            const response = await fetch(`${configs().backendUrl}/nodes/change-market`, {
                method: 'POST',
                headers: {
                    Authorization: `${this.address}:${await this.getAuthSignature()}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ address: this.address }),
            });
            const data = await response.json();
            if (!data || data.name === 'Error')
                throw new Error(data.message);
            // Incase of blockheight exceeded error, retry 3 times
            for (let i = 0; i < 3; i++) {
                try {
                    const txnSignature = await this.signAndSendTransaction(data.tx);
                    await this.confirmTransaction(txnSignature);
                    break;
                }
                catch (error) {
                    if (i === 2 ||
                        !error?.message.includes('TransactionExpiredBlockheightExceededError')) {
                        throw error;
                    }
                }
            }
            // TODO: verify tx result with code below
            // const result = await this.sdk.solana.connection?.getTransaction(
            //   txnSignature as string,
            //   { maxSupportedTransactionVersion: 0 },
            // );
            // // @ts-ignore
            // if (result?.meta?.status.Err) {
            //   // @ts-ignore
            //   throw new Error(JSON.stringify(result?.meta?.status.Err));
            // }
            await sleep(30);
            await this.syncNodeAfterMint();
            return data;
        }
        catch (error) {
            throw new Error('Something went wrong with minting your access key, please try again. ' +
                error);
        }
    }
    async signAndSendTransaction(txData) {
        const feePayer = (this.sdk.solana.provider?.wallet).payer;
        const recoveredTransaction = await getRawTransaction(Uint8Array.from(Object.values(txData)));
        if (recoveredTransaction instanceof VersionedTransaction) {
            recoveredTransaction.sign([feePayer]);
        }
        else {
            recoveredTransaction.partialSign(feePayer);
        }
        const txnSignature = await this.sdk.solana.connection?.sendRawTransaction(recoveredTransaction.serialize());
        return txnSignature;
    }
    async confirmTransaction(txnSignature) {
        const latestBlockHash = await this.sdk.solana.connection?.getLatestBlockhash();
        if (latestBlockHash && txnSignature) {
            const confirmStrategy = {
                blockhash: latestBlockHash.blockhash,
                lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
                signature: txnSignature,
            };
            await this.sdk.solana.connection?.confirmTransaction(confirmStrategy);
        }
        else {
            throw new Error('Could not confirm minting transaction');
        }
    }
    async syncNodeAfterMint() {
        try {
            const response = await fetch(`${configs().backendUrl}/nodes/sync-node`, {
                method: 'POST',
                headers: {
                    Authorization: `${this.address}:${await this.getAuthSignature()}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ address: this.address }),
            });
            return response.json();
        }
        catch (error) {
            throw error;
        }
    }
}
