import { applyLoggingProxyToClass } from '../../../monitoring/proxy/loggingProxy.js';
import { hoursSinceDate } from '../helpers/hoursSunceDate.js';
import { repoTagsContainsImage } from '../helpers/repoTagsContainsImage.js';
export class ImageManager {
    constructor(containerOrchestration, repository) {
        this.containerOrchestration = containerOrchestration;
        this.repository = repository;
        this.fetched = false;
        this.market_required_images = [];
        applyLoggingProxyToClass(this);
    }
    async pullMarketRequiredImages(required_images) {
        this.fetched = true;
        this.market_required_images = required_images;
        for (const image of required_images) {
            if (!(await this.containerOrchestration.hasImage(image))) {
                await this.containerOrchestration.pullImage(image);
            }
            if (!this.repository.getImageResource(image)) {
                this.repository.updateImageResource(image, {
                    required: true,
                    lastUsed: new Date(),
                    usage: 1,
                });
            }
        }
    }
    async pruneImages() {
        const cachedImages = await this.containerOrchestration.listImages();
        for (const { Id, RepoTags } of cachedImages) {
            const dbEntry = Object.entries(this.repository.getImagesResources()).find((img) => (repoTagsContainsImage(img[0], RepoTags) ? img : undefined));
            if (dbEntry && dbEntry[1].required) {
                continue;
            }
            await this.containerOrchestration.deleteImage(Id);
            if (dbEntry) {
                this.repository.deleteImageResource(dbEntry[0]);
            }
        }
    }
    async resyncImagesDB() {
        for (const [image, { lastUsed, required }] of Object.entries(this.repository.getImagesResources())) {
            if (!(await this.containerOrchestration.hasImage(image))) {
                this.repository.deleteImageResource(image);
                continue;
            }
            if ((!this.fetched && required) ||
                this.market_required_images.includes(image)) {
                continue;
            }
            const hoursSinceLastUsed = hoursSinceDate(new Date(lastUsed));
            if (hoursSinceLastUsed > 24) {
                await this.containerOrchestration.deleteImage(image);
                this.repository.deleteImageResource(image);
            }
        }
    }
    async setImage(image) {
        const imageObj = this.repository.getImageResource(image);
        this.repository.updateImageResource(image, {
            required: true,
            lastUsed: new Date(),
            usage: imageObj?.usage + 1 || 1,
        });
    }
}
