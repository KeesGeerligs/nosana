import EventEmitter from 'events';
import { PublicKey } from '@solana/web3.js';
import { FlowHandler } from '../flow/flowHandler.js';
import { applyLoggingProxyToClass } from '../../monitoring/proxy/loggingProxy.js';
import { validateJobDefinition } from '../../../../providers/Provider.js';
import { JobExternalUtil } from './jobExternalUtil.js';
export const jobEmitter = new EventEmitter();
export class JobHandler {
    constructor(sdk, provider, repository) {
        this.sdk = sdk;
        this.provider = provider;
        this.repository = repository;
        this.finishing = false;
        this.flowHandler = new FlowHandler(this.provider, repository);
        this.jobExternalUtil = new JobExternalUtil(sdk, this.repository);
        applyLoggingProxyToClass(this);
        this.eventEmitter = new EventEmitter();
        this.accountEmitter = new EventEmitter();
        jobEmitter.on('run-exposed', (data) => {
            this.flowHandler.operationExposed(data.id);
        });
    }
    /**
     * Expose a method to allow external consumers to listen for events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Expose a method to remove listeners
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
    get() {
        return this.job;
    }
    jobId() {
        if (!this.id) {
            throw new Error('Job ID is not set');
        }
        return this.id;
    }
    getJobOrThrow() {
        if (!this.job) {
            throw new Error('Job is not set');
        }
        return this.job;
    }
    clearJob() {
        this.job = undefined;
    }
    async claim(jobAddress) {
        try {
            const job = await this.sdk.jobs.get(jobAddress);
            this.id = jobAddress;
            this.job = job;
            return job;
        }
        catch (_) {
            throw new Error('could not start job');
        }
    }
    async stop() {
        if (this.id) {
            await this.flowHandler.stop(this.jobId());
        }
        this.stopListeningForAccountChanges();
        this.clearJob();
    }
    async validate(jobDefinition) {
        const validation = validateJobDefinition(jobDefinition);
        if (!validation.success) {
            this.repository.updateflowStateError(this.jobId(), {
                status: 'validation-error',
                errors: validation.errors,
            });
            return false;
        }
        return true;
    }
    listenForAccountChanges() {
        return new Promise(async (resolve, reject) => {
            try {
                await this.sdk.jobs.loadNosanaJobs();
                this.runSubscriptionId = this.sdk.jobs.connection.onAccountChange(new PublicKey(this.jobId()), (accountInfo) => {
                    const jobAccount = this.sdk.jobs.jobs.coder.accounts.decode(this.sdk.jobs.jobs.account.jobAccount.idlAccount.name, accountInfo.data);
                    if (jobAccount.state >= 2) {
                        this.accountEmitter.emit('stopped', jobAccount);
                        resolve();
                        return;
                    }
                    this.accountEmitter.emit('changed', jobAccount);
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
    stopListeningForAccountChanges() {
        if (this.runSubscriptionId !== undefined) {
            this.sdk.jobs.connection.removeProgramAccountChangeListener(this.runSubscriptionId);
            this.runSubscriptionId = undefined;
        }
    }
    async start(job) {
        const flow = this.repository.getflow(this.jobId());
        if (!flow) {
            this.flowHandler.init(this.jobId());
            let jobDefinition = await this.jobExternalUtil.resolveJobDefinition(this.jobId(), job);
            if (!(await this.jobExternalUtil.validate(this.jobId(), jobDefinition))) {
                return false;
            }
            this.flowHandler.start(this.jobId(), jobDefinition);
        }
        else {
            this.flowHandler.resume(this.jobId());
        }
        this.listenForAccountChanges();
        return true;
    }
    async run() {
        try {
            if (this.repository.getFlowState(this.jobId()).status == 'failed') {
                return false;
            }
            await this.flowHandler.run(this.jobId());
            if (this.repository.getFlowState(this.jobId()).status == 'failed') {
                return false;
            }
            return true;
        }
        catch (error) {
            this.eventEmitter.emit('error', error);
            return false;
        }
    }
    async runWithErrorHandling() {
        return new Promise((resolve, reject) => {
            const errorHandler = (error) => {
                this.off('error', errorHandler);
                reject(error);
            };
            this.on('error', errorHandler);
            this.run()
                .then(() => {
                this.off('error', errorHandler);
                resolve();
            })
                .catch((error) => {
                this.off('error', errorHandler);
                reject(error);
            });
        });
    }
    async stopCurrentJob() {
        await this.flowHandler.stopCurrentFlow();
    }
    async quit(run) {
        await this.sdk.jobs.quit(run);
        await this.flowHandler.stop(this.jobId());
    }
    exposed() {
        return this.flowHandler.exposed(this.jobId());
    }
    async finish(run) {
        if (!this.repository.getflow(this.jobId())) {
            return;
        }
        try {
            let result = await this.jobExternalUtil.resolveResult(this.jobId());
            const ipfsResult = await this.sdk.ipfs.pin(result);
            const bytesArray = this.sdk.ipfs.IpfsHashToByteArray(ipfsResult);
            await this.sdk.jobs.submitResult(bytesArray, run, this.getJobOrThrow().market.toString());
        }
        catch (e) {
            throw new Error(`Failed to finish job: ${e}`);
        }
    }
    async clearOldJobs() {
        await this.flowHandler.clearOldFlows();
    }
}
