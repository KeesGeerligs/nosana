export class MarketHandler {
    constructor(sdk) {
        this.sdk = sdk;
        this.inMarket = false;
        this.address = this.sdk.solana.provider.wallet.publicKey;
    }
    clear() {
        this.market = undefined;
    }
    isInMarket() {
        return this.inMarket;
    }
    setInMarket() {
        this.inMarket = true;
    }
    async check(market) {
        try {
            return await this.sdk.jobs.getMarket(market);
        }
        catch (error) {
            throw new Error(`Error resolving Market: ${error}`);
        }
    }
    async stopMarket() {
        if (this.market) {
            try {
                await this.sdk.jobs.stop(this.market.address);
            }
            catch (e) {
                return false;
            }
        }
        return true;
    }
    async getJobMarket(market) {
        try {
            this.market = await this.sdk.jobs.getMarket(market);
            return this.market;
        }
        catch (error) {
            throw new Error('market does not exists');
        }
    }
    getMarket() {
        return this.market;
    }
    async setMarket(market) {
        try {
            this.market = await this.sdk.jobs.getMarket(market);
            return this.market;
        }
        catch (error) {
            throw new Error('market does not exists');
        }
    }
    async checkQueuedInMarket() {
        let markets = [];
        markets = await this.sdk.jobs.allMarkets();
        for (const market of markets) {
            if (market?.queue?.some((e) => e.toString() === this.address.toString())) {
                this.market = market;
                return this.getMarket();
            }
        }
        return undefined;
    }
    async join(accessKey) {
        if (!this.market) {
            throw new Error('market not defined');
        }
        try {
            await this.sdk.jobs.work(this.market.address, accessKey);
            this.inMarket = true;
        }
        catch (_) {
            throw new Error('could not join queue');
        }
        return this.market;
    }
    async refresh() {
        return this.setMarket(this.market?.address.toString());
    }
    async leave() {
        if (this.market) {
            try {
                await this.sdk.jobs.stop(this.market.address);
            }
            catch (error) { }
            this.inMarket = false;
        }
    }
    processMarketQueuePosition(market, isFirst) {
        const position = market.queue.findIndex((e) => e.toString() === this.address.toString()) + 1;
        return {
            position,
            count: market.queue.length,
        };
    }
    async startMarketQueueMonitoring(updateCallback) {
        // Ensure no multiple intervals
        this.stopMarketQueueMonitoring();
        try {
            // Perform an immediate check
            const queuedMarketInfo = await this.checkQueuedInMarket();
            updateCallback(queuedMarketInfo);
        }
        catch (e) {
            console.warn('\nCould not update queue status', e);
        }
        // Check market queue status every 2 minutes
        this.checkQueuedInterval = setInterval(async () => {
            try {
                const queuedMarketInfo = await this.checkQueuedInMarket();
                updateCallback(queuedMarketInfo);
            }
            catch (e) {
                console.warn('\nCould not update queue status', e);
            }
        }, 60000 * 2);
    }
    // Stop monitoring market queue status
    stopMarketQueueMonitoring() {
        if (this.checkQueuedInterval) {
            clearInterval(this.checkQueuedInterval);
            this.checkQueuedInterval = undefined; // Clean up reference
        }
    }
    async stop() {
        this.stopMarketQueueMonitoring();
        await this.leave();
        this.clear();
    }
}
