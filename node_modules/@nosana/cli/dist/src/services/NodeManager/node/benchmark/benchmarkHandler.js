import { configs } from '../../configs/configs.js';
import { FlowHandler } from '../flow/flowHandler.js';
import { benchmarkGPU, jobDefinition, } from '../../../../static/staticsImports.js';
import { applyLoggingProxyToClass } from '../../monitoring/proxy/loggingProxy.js';
export class BenchmarkHandler {
    constructor(provider, repository) {
        this.provider = provider;
        this.repository = repository;
        this.flowHandler = new FlowHandler(this.provider, repository);
        applyLoggingProxyToClass(this);
    }
    async check(isInMarket) {
        const id = this.flowHandler.generateRandomId(32);
        this.flowHandler.start(id, isInMarket ? benchmarkGPU : jobDefinition);
        let result;
        try {
            result = await this.flowHandler.run(id);
        }
        catch (error) {
            throw error;
        }
        if (result) {
            this.repository.deleteflow(result.id);
            if (result && result.state.status === 'success') {
                await this.processSuccess(result.state.opStates);
            }
            else if (result && result.state.status === 'failed') {
                this.processFailure(result.state.opStates);
            }
            else {
                throw new Error('Cannot find results');
            }
            return true;
        }
        return false;
    }
    processSuccess(opStates) {
        if (!opStates) {
            throw new Error('Missing operation states in result');
        }
        for (const { operationId, logs } of opStates) {
            switch (operationId) {
                case 'system-info':
                    this.processSystemInfoBenchmark(logs);
                    break;
                case 'network-info':
                    this.processNetworkInfoBenchmark(logs);
                    break;
                case 'gpu-info':
                    this.processGPUInfoBenchmark(logs);
                    break;
            }
        }
    }
    parseLogsIntoJSON(logs) {
        return JSON.parse(logs.reduce((result, { log, type }) => type === 'stdout' ? result + log : result, ''));
    }
    processFailure(opStates) {
        const errors = [];
        if (opStates[0]) {
            try {
                const cudaCheckResults = JSON.parse(opStates[0].logs[0].log);
                if (cudaCheckResults.error) {
                    errors.push('GPU benchmark failed. Ensure NVidia Cuda runtime drivers and NVidia Container Toolkit are correctly configured.');
                }
            }
            catch (error) {
                errors.push('GPU benchmark returned with no devices.');
            }
        }
        if (opStates[1]) {
            errors.push('Disk space check failed.');
        }
        if (errors.length > 0) {
            throw new Error(errors.join(' '));
        }
    }
    processSystemInfoBenchmark(logs) {
        if (!logs[0])
            throw new Error('Could not find system info logs');
        const { cpu_model: model, logical_cores, physical_cores, ram_mb, disk_gb, } = this.parseLogsIntoJSON(logs);
        if (configs().minDiskSpace > disk_gb) {
            throw new Error(`Node does not have enough disk space. Required: ${configs().minDiskSpace}GB, Available: ${disk_gb}GB`);
        }
        this.repository.updateNodeInfo({
            cpu: {
                model,
                logical_cores,
                physical_cores,
            },
            ram_mb,
            disk_gb,
        });
    }
    processNetworkInfoBenchmark(logs) {
        if (!logs[0])
            throw new Error('Could not find network info logs');
        const { country, ip, ping_ms, download_mbps, upload_mbps } = this.parseLogsIntoJSON(logs);
        this.repository.updateNodeInfo({
            country,
            network: {
                ip,
                ping_ms,
                download_mbps,
                upload_mbps,
            },
        });
    }
    processGPUInfoBenchmark(logs) {
        if (!logs[0])
            throw new Error('Could not find GPU info logs');
        const results = this.parseLogsIntoJSON(logs);
        this.repository.updateNodeInfo({ gpus: results });
    }
}
