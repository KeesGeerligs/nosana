import { clientSelector } from '../../../../api/client.js';
import { createResourceName } from './helpers/createResourceName.js';
import { ImageManager } from './image/imageManager.js';
import { VolumeManager } from './volume/volumeManager.js';
export class ResourceManager {
    constructor(containerOrchestration, repository) {
        this.containerOrchestration = containerOrchestration;
        this.repository = repository;
        this.images = new ImageManager(containerOrchestration, repository);
        this.volumes = new VolumeManager(containerOrchestration, repository);
    }
    async resyncResourcesDB() {
        await this.images.resyncImagesDB();
        await this.volumes.resyncResourcesDB();
        if (this.required_market) {
            await this.fetchMarketRequiredResources(this.required_market);
        }
    }
    async fetchMarketRequiredResources(market) {
        this.required_market = market;
        try {
            const { data, error } = await clientSelector().GET('/api/markets/{id}/required-resources', { params: { path: { id: market } } });
            if (error) {
                return;
            }
            await this.images.pullMarketRequiredImages(data.required_images);
            await this.volumes.pullMarketRequiredVolumes(data.required_remote_resources);
        }
        catch (error) {
            throw error;
        }
    }
    async prune() {
        await this.images.pruneImages();
        await this.volumes.pruneVolumes();
    }
    async getResourceVolumes(resources) {
        const volumes = [];
        for (const resource of resources) {
            await this.volumes.createRemoteVolume(resource);
            if ((await this.volumes.hasVolume(resource)) === false) {
                const error = new Error(`Missing required resource ${createResourceName(resource)}.`);
                throw error;
            }
            volumes.push({
                dest: resource.target,
                name: await this.volumes.getVolume(resource),
                readonly: resource.allowWrite ? false : true,
            });
        }
        return volumes;
    }
}
