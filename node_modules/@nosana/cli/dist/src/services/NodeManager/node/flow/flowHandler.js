import { applyLoggingProxyToClass } from '../../monitoring/proxy/loggingProxy.js';
export class FlowHandler {
    constructor(provider, repository) {
        this.provider = provider;
        this.repository = repository;
        applyLoggingProxyToClass(this);
    }
    init(id) {
        this.repository.setflow(id, this.createInitFlow(id));
    }
    start(id, jobDefinition) {
        this.repository.setflow(id, this.createNewFlow(id, jobDefinition));
        for (let i = 0; i < jobDefinition.ops.length; i++) {
            this.repository.addOpstate(id, this.createOpNewState(jobDefinition.ops[i].id));
        }
        return this.repository.getflow(id);
    }
    resume(id) {
        return this.repository.getflow(id);
    }
    async run(id) {
        const flow = this.repository.getflow(id);
        for (let i = 0; i < flow.jobDefinition.ops.length; i++) {
            const op = flow.jobDefinition.ops[i];
            const opState = this.repository.getOpState(id, i);
            if (!opState.endTime) {
                try {
                    if (!(await this.provider.runOperation(op.type, {
                        id,
                        index: i,
                        name: this.repository.getFlowOperationName(id, i),
                    }))) {
                        this.repository.updateflowState(id, {
                            endTime: Date.now(),
                            status: 'failed',
                        });
                        return this.repository.getflow(id);
                    }
                }
                catch (error) {
                    this.repository.updateflowStateError(id, error);
                    this.repository.updateflowState(id, {
                        endTime: Date.now(),
                        status: 'failed',
                    });
                    return this.repository.getflow(id);
                }
            }
        }
        try {
            for (let i = 0; i < flow.jobDefinition.ops.length; i++) {
                const op = flow.jobDefinition.ops[i];
                try {
                    await this.provider.stopOperation(op.type, {
                        id,
                        index: i,
                        name: this.repository.getFlowOperationName(id, i),
                    });
                }
                catch (_) { }
            }
        }
        catch (_) { }
        this.repository.updateflowState(id, {
            status: 'success',
            endTime: Date.now(),
        });
        return this.repository.getflow(id);
    }
    async stopCurrentFlow() {
        await this.provider.finishCurrentRunningContainer();
    }
    async stop(id) {
        const flow = this.repository.getflow(id);
        if (!flow) {
            return;
        }
        try {
            for (let i = 0; i < flow.jobDefinition.ops.length; i++) {
                const op = flow.jobDefinition.ops[i];
                try {
                    await this.provider.stopOperation(op.type, {
                        id,
                        index: i,
                        name: this.repository.getFlowOperationName(id, i),
                    });
                }
                catch (_) { }
            }
        }
        catch (_) { }
        this.repository.updateflowState(id, {
            endTime: Date.now(),
            status: 'stopped',
        });
    }
    createInitFlow(id) {
        return {
            id,
            jobDefinition: {
                version: '',
                type: 'container',
                ops: [],
            },
            state: {
                status: 'init',
                startTime: Date.now(),
                endTime: null,
                opStates: [],
                secrets: {},
            },
        };
    }
    createNewFlow(id, jobDefinition) {
        return {
            id,
            jobDefinition,
            state: {
                status: 'running',
                startTime: Date.now(),
                endTime: null,
                opStates: [],
                secrets: {},
            },
        };
    }
    createOpNewState(id) {
        return {
            operationId: id,
            providerId: null,
            status: 'pending',
            startTime: null,
            endTime: null,
            exitCode: null,
            logs: [],
        };
    }
    exposed(id) {
        return this.repository
            .getflow(id)
            .jobDefinition.ops.some((op) => op.type === 'container/run' &&
            op.args.expose !== undefined);
    }
    private(id) {
        return this.repository
            .getflow(id)
            .jobDefinition.ops.some((op) => op.type === 'container/run' &&
            op.args.expose !== undefined &&
            op.args.private === true);
    }
    operationExposed(id) {
        return this.repository.getFlowSecret(id, 'url') ?? 'private';
    }
    async clearOldFlows() {
        const date = new Date();
        date.setDate(date.getDate() - 3);
        for (const id in this.repository.getFlows()) {
            const flow = this.repository.getflow(id);
            if (flow.state.endTime && flow.state.endTime < date.valueOf()) {
                this.repository.deleteflow(id);
            }
        }
    }
    generateRandomId(length) {
        return [...Array(length)].map(() => Math.random().toString(36)[2]).join('');
    }
}
