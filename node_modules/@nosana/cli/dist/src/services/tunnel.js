import { Readable, Duplex } from 'stream';
import http from 'http';
import { io } from 'socket.io-client';
import { HttpsProxyAgent } from 'https-proxy-agent';
let socket = null;
let keepAliveInterval = null;
function stopKeepAlive() {
    if (keepAliveInterval) {
        clearInterval(keepAliveInterval);
        keepAliveInterval = null;
    }
}
function keepAlive() {
    if (!keepAliveInterval) {
        keepAliveInterval = setInterval(async () => {
            if (socket && socket.connected) {
                // console.log('ping');
                socket.send('ping');
            }
            else {
                // console.log('socket not connected');
            }
        }, 5000); // check every 5 sec
    }
}
export function stopTunnel() {
    if (socket) {
        socket.close();
    }
    stopKeepAlive();
}
export function initTunnel(options) {
    const initParams = {
        path: '/$web_tunnel',
        transports: ['websocket'],
        extraHeaders: {},
    };
    if (options.path) {
        initParams.extraHeaders['path-prefix'] = options.path;
    }
    const http_proxy = process.env.https_proxy || process.env.http_proxy;
    if (http_proxy) {
        // @ts-ignore
        initParams.agent = new HttpsProxyAgent(http_proxy);
    }
    socket = io(options.server, initParams);
    socket.on('connect', () => {
        if (socket.connected) {
            keepAlive();
            // TODO: replace with node logger?
            // console.log('client connect to server successfully');
        }
    });
    socket.on('connect_error', (e) => {
        // TODO: replace with node logger?
        // console.log('connect error', e && e.message);
    });
    socket.on('disconnect', (reason, details) => {
        stopKeepAlive();
        // console.log('socket disconnect', reason, details);
        if (reason === 'transport close' &&
            // @ts-ignore
            details.description === 'websocket connection closed') {
            // socket!.close();
        }
    });
    socket.on('request', (requestId, request) => {
        const isWebSocket = request.headers.upgrade === 'websocket';
        // TODO: use node logger with a new event type
        // console.log(`${isWebSocket ? 'WS' : request.method}: `, request.path);
        request.port = options.port;
        request.hostname = options.host;
        if (options.origin) {
            request.headers.host = options.origin;
        }
        const tunnelRequest = new TunnelRequest({
            requestId,
            socket: socket,
        });
        const localReq = http.request(request);
        tunnelRequest.pipe(localReq);
        const onTunnelRequestError = (e) => {
            tunnelRequest.off('end', onTunnelRequestEnd);
            localReq.destroy(e);
        };
        const onTunnelRequestEnd = () => {
            tunnelRequest.off('error', onTunnelRequestError);
        };
        tunnelRequest.once('error', onTunnelRequestError);
        tunnelRequest.once('end', onTunnelRequestEnd);
        const onLocalResponse = (localRes) => {
            localReq.off('error', onLocalError);
            if (isWebSocket && localRes.upgrade) {
                return;
            }
            const tunnelResponse = new TunnelResponse({
                responseId: requestId,
                socket: socket,
            });
            tunnelResponse.writeHead(localRes.statusCode, localRes.statusMessage, localRes.headers, localRes.httpVersion);
            localRes.pipe(tunnelResponse);
        };
        const onLocalError = (error) => {
            // console.log(error);
            localReq.off('response', onLocalResponse);
            socket.emit('request-error', requestId, error && error.message);
            tunnelRequest.destroy(error);
        };
        const onUpgrade = (localRes, localSocket, localHead) => {
            // localSocket.once('error', onTunnelRequestError);
            if (localHead && localHead.length)
                localSocket.unshift(localHead);
            const tunnelResponse = new TunnelResponse({
                responseId: requestId,
                socket: socket,
                duplex: true,
            });
            tunnelResponse.writeHead(null, null, localRes.headers);
            localSocket.pipe(tunnelResponse).pipe(localSocket);
        };
        localReq.once('error', onLocalError);
        localReq.once('response', onLocalResponse);
        if (isWebSocket) {
            localReq.on('upgrade', onUpgrade);
        }
    });
}
export class TunnelRequest extends Readable {
    constructor({ socket, requestId }) {
        super();
        this._socket = socket;
        this._requestId = requestId;
        const onRequestPipe = (requestId, data) => {
            if (this._requestId === requestId) {
                this.push(data);
            }
        };
        const onRequestPipes = (requestId, data) => {
            if (this._requestId === requestId) {
                data.forEach((chunk) => {
                    this.push(chunk);
                });
            }
        };
        const onRequestPipeError = (requestId, error) => {
            if (this._requestId === requestId) {
                this._socket.off('request-pipe', onRequestPipe);
                this._socket.off('request-pipes', onRequestPipes);
                this._socket.off('request-pipe-error', onRequestPipeError);
                this._socket.off('request-pipe-end', onRequestPipeEnd);
                this.destroy(new Error(error));
            }
        };
        const onRequestPipeEnd = (requestId, data) => {
            if (this._requestId === requestId) {
                this._socket.off('request-pipe', onRequestPipe);
                this._socket.off('request-pipes', onRequestPipes);
                this._socket.off('request-pipe-error', onRequestPipeError);
                this._socket.off('request-pipe-end', onRequestPipeEnd);
                if (data) {
                    this.push(data);
                }
                this.push(null);
            }
        };
        this._socket.on('request-pipe', onRequestPipe);
        this._socket.on('request-pipes', onRequestPipes);
        this._socket.on('request-pipe-error', onRequestPipeError);
        this._socket.on('request-pipe-end', onRequestPipeEnd);
    }
    _read() { }
}
export class TunnelResponse extends Duplex {
    constructor({ socket, responseId, duplex, }) {
        super();
        this._socket = socket;
        this._responseId = responseId;
        if (duplex) {
            // for websocket requestï¼š bidirection
            const onResponsePipe = (responseId, data) => {
                if (this._responseId === responseId) {
                    this.push(data);
                }
            };
            const onResponsePipes = (responseId, data) => {
                if (this._responseId === responseId) {
                    data.forEach((chunk) => {
                        this.push(chunk);
                    });
                }
            };
            const onResponsePipeError = (responseId, error) => {
                if (this._responseId === responseId) {
                    this._socket.off('response-pipe', onResponsePipe);
                    this._socket.off('response-pipes', onResponsePipes);
                    this._socket.off('response-pipe-error', onResponsePipeError);
                    this._socket.off('response-pipe-end', onResponsePipeEnd);
                    this.destroy(new Error(error));
                }
            };
            const onResponsePipeEnd = (responseId, data) => {
                if (this._responseId === responseId) {
                    this._socket.off('response-pipe', onResponsePipe);
                    this._socket.off('response-pipes', onResponsePipes);
                    this._socket.off('response-pipe-error', onResponsePipeError);
                    this._socket.off('response-pipe-end', onResponsePipeEnd);
                    if (data) {
                        this.push(data);
                    }
                    this.push(null);
                }
            };
            this._socket.on('response-pipe', onResponsePipe);
            this._socket.on('response-pipes', onResponsePipes);
            this._socket.on('response-pipe-error', onResponsePipeError);
            this._socket.on('response-pipe-end', onResponsePipeEnd);
        }
    }
    _write(chunk, encoding, callback) {
        this._socket.emit('response-pipe', this._responseId, chunk);
        this._socket.io.engine.once('drain', () => {
            callback();
        });
    }
    _writev(chunks, callback) {
        this._socket.emit('response-pipes', this._responseId, chunks);
        this._socket.io.engine.once('drain', () => {
            callback();
        });
    }
    _final(callback) {
        this._socket.emit('response-pipe-end', this._responseId);
        this._socket.io.engine.once('drain', () => {
            callback();
        });
    }
    _destroy(e, callback) {
        if (e) {
            this._socket.emit('response-pipe-error', this._responseId, e && e.message);
            this._socket.io.engine.once('drain', () => {
                callback();
            });
            return;
        }
        callback();
    }
    writeHead(statusCode, statusMessage, headers, httpVersion) {
        this._socket.emit('response', this._responseId, {
            statusCode,
            statusMessage,
            headers,
            httpVersion,
        });
    }
    _read(size) { }
}
